\documentclass[11pt]{article}

\usepackage{../handout}
\usepackage{graphicx}

\input{../mymargins}
\input{../handout-number}

\begin{document}
\handout{\WATwoNum}{2}{Written Assignment 2 \\ Due October 21 at 5:00 PM}

This assignment asks you to prepare written answers to questions on
context-free grammars, parse trees, and parsing.  Each of the questions has a short answer. 
You may discuss this assignment with other students and work on the problems
together, but your write-up must be your own individual work.  Remember
that written assignments are to be turned in either at the start of lecture, 
electronically, or in Prof. Aiken's Office (Gates 411) by 5:00 PM on the due date.

\bigskip

\begin{enumerate}
	% #1
	\item Give a context-free grammar (CFG) for each of the following languages
		over the alphabet $\Sigma = \{0, 1\}$:
		\begin{enumerate}
			\item All nonempty strings that start and end with the same symbol.
			\item All strings that contain more $1$s than $0$s.
			\item All palindromes (a palindrome is a string that reads the same
				forwards and backwards).
		\end{enumerate}
	
	% #2
	\item Consider the following grammar:
		\begin{eqnarray*}
			S & \rightarrow & aSb \\
			S & \rightarrow & aS \\
			S & \rightarrow & \epsilon \\
		\end{eqnarray*}
		\begin{enumerate}
			\item Give a one-sentence description of the language generated by this
			grammar.
			\item Show that this grammar is ambiguous by giving a string that can be
			parsed in two different ways.  Draw both parse trees.
			\item Give an unambiguous grammar that accepts the same language as the
			grammar above.
		\end{enumerate}
	
	% #3
	\item The Cool Reference Manual, in Chapter 11, has the context-free
		grammar defining the syntax for Cool.  Create the parse tree from the
		grammar definition for the following class definition.
		
		\begin{verbatim}
			class FOO inherits BAR {
			  i : Int <- 42;
			  baz (x:Int) : Foo { i <- x + i }; 
			};
		\end{verbatim}
		
		You do not need to construct nonterminals that immediately produce
		terminals, or include terminals which add no meaning because they are
		captured by the nature of the production.  For example, for the
		expression ``1 + 2'', the following parse tree would be sufficient:
		\begin{verbatim}
		             ADD
		            /   \ 
		           /     \
		         INT     INT
		         (1)     (2)
		\end{verbatim}
	
	% #4
	\item Give a one-sentence description of the language generated by
		each of the following CFGs.
		\begin{enumerate}
			\item
				\begin{eqnarray*}
				S & \rightarrow & Z1Z1Z1A \\
				Z & \rightarrow & Z0 \mid \varepsilon \\
				A & \rightarrow & A0 \mid A1 \mid \varepsilon
				\end{eqnarray*}
			\item
				\begin{eqnarray*}
				S & \rightarrow & 0 \mid 1 \mid 0S0 \mid 0S1 \mid 1S0 \mid 1S1
				\end{eqnarray*}
		\end{enumerate}
	
	% #5
	\item Give an example of a simple grammar that is $LL(2)$ but not $LL(1)$.
	
	% #6
	\item Consider the following CFG, which has the set of terminals
		$T = \{ \textbf{id}, \textbf{(}, \textbf{)}, \textbf{[}, \textbf{]},
		\textbf{;} \}$.
		\begin{eqnarray*}
			E & \rightarrow &
			\mathbf{id} \mid \mathbf{id} \textbf{(} A \textbf{)} \mid \textbf{id}
			\textbf{[} E \textbf{]} \\
			A & \rightarrow & E \mid E \; \textbf{;} \; A
		\end{eqnarray*}
		
		\begin{enumerate}
			\item Left-factor this grammar so that no two productions with the
				same left-hand side have right-hand sides with a common prefix.
			\item Construct an LL(1) parsing table for the left-factored grammar.
			\item Show the operation of an LL(1) parser on the input string
				\textbf{id(id[id]; id)}.
		\end{enumerate}
	
	% #7
	\item Consider the following CFG, which has the set of terminals
		$T = \{ \textbf{a}, \textbf{b} \}$.
		\begin{eqnarray*}
			S & \rightarrow & X \textbf{a} \\
			X & \rightarrow & \textbf{a} \mid \textbf{a} X \textbf{b}
		\end{eqnarray*}
	
		\begin{enumerate}
			\item Construct a DFA for viable prefixes of this grammar using LR(0)
				items.
			\item Identify a shift-reduce conflict in this grammar under the
				SLR(1) rules.
			\item Assuming that an SLR(1) parser resolves shift-reduce conflicts
				by choosing to shift, show the operation of such a parser on the input
				string \textbf{aaba}.
			\item Suppose that the production $X \rightarrow \varepsilon$ is added
				to this grammar.  Identify a reduce-reduce conflict in the resulting
				grammar under the SLR(1) rules.
		\end{enumerate}
	
\end{enumerate}
\end{document}
