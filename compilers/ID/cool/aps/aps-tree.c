/* Generated by a program written by John Boyland */
#include <stdio.h>
#include "aps-tree.h"
#include "aps-tree.handcode.i"
#include "tree.i"
/* Automatically generated file */

/* Declaration for lists used in this language */


/* Typecase of what phylum a node has */

enum KEYTYPE_Phylum tnode_phylum(void *tnode) {
  if (tnode == 0) return KEYNone;
  switch (((TNODE)tnode)->operator) {
    default:
      return KEYNone;
    case 12423:
    case 12524:
    case 12625:
    case 12726:
    case 13231:
    case 13332:
    case 13433:
    case 13534:
      return KEYSignature;
    case 11716:
    case 11817:
    case 11918:
    case 12019:
    case 13635:
    case 13736:
    case 13837:
    case 13938:
    case 14039:
      return KEYType;
    case 12120:
    case 12221:
    case 12322:
    case 15857:
    case 15958:
    case 16059:
    case 16160:
    case 16261:
    case 16362:
    case 16463:
    case 16564:
    case 16665:
    case 16766:
    case 16867:
    case 16968:
    case 17069:
    case 17170:
    case 17271:
      return KEYExpression;
    case 12827:
    case 12928:
    case 13029:
    case 13130:
    case 14140:
    case 14241:
    case 14342:
    case 14443:
    case 14544:
    case 14645:
    case 14746:
    case 14847:
      return KEYPattern;
    case 11312:
      return KEYSignatureDecl;
    case 11413:
      return KEYTypeDecl;
    case 11514:
      return KEYValueDecl;
    case 11615:
      return KEYPatternDecl;
    case 7878:
      return KEYProgram;
    case 7979:
    case 8080:
    case 8181:
      return KEYUnit;
    case 8282:
    case 8383:
    case 8484:
    case 8585:
    case 8686:
    case 8787:
    case 8888:
    case 8989:
    case 9090:
    case 9191:
    case 9292:
    case 9393:
    case 9494:
    case 9595:
    case 14948:
    case 15049:
    case 15150:
    case 15251:
    case 15352:
    case 15453:
    case 15554:
    case 15655:
      return KEYDeclaration;
    case 9696:
    case 9797:
    case 9898:
    case 9999:
    case 10100:
    case 10201:
    case 10302:
    case 10403:
    case 10504:
      return KEYRenaming;
    case 15756:
      return KEYMatch;
    case 10605:
    case 10706:
    case 10807:
      return KEYDirection;
    case 10908:
    case 11009:
    case 11110:
    case 11211:
      return KEYDefault;
    case 2727:
    case 2828:
    case 2929:
      return KEYUnits;
    case 3131:
    case 3232:
    case 3333:
      return KEYDeclarations;
    case 3535:
    case 3636:
    case 3737:
      return KEYMatches;
    case 3939:
    case 4040:
    case 4141:
      return KEYRenamings;
    case 4343:
    case 4444:
    case 4545:
      return KEYSignatures;
    case 4747:
    case 4848:
    case 4949:
      return KEYTypes;
    case 5151:
    case 5252:
    case 5353:
      return KEYExpressions;
    case 5555:
    case 5656:
    case 5757:
      return KEYPatterns;
    case 5959:
    case 6060:
    case 6161:
      return KEYFormals;
    case 6363:
    case 6464:
    case 6565:
      return KEYTypeFormals;
    case 6767:
    case 6868:
    case 6969:
      return KEYActuals;
    case 7171:
    case 7272:
    case 7373:
      return KEYTypeActuals;
    case 7575:
    case 7676:
    case 7777:
      return KEYPatternActuals;
  }
}

/* Phyla, constructors and accessors */

enum KEYTYPE_Signature Signature_KEY(Signature _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Signature");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Signature",
                         _node,((TNODE)_node)->operator);
    case 12423: return KEYsig_name;
    case 12524: return KEYno_sig;
    case 12625: return KEYsig_inst;
    case 12726: return KEYqual_sig;
    case 13231: return KEYvar_sig;
    case 13332: return KEYconstant_sig;
    case 13433: return KEYmodule_sig;
    case 13534: return KEYfixed_sig;
  }
}
char *Signature_constructors[] = {
  "sig_name",
  "no_sig",
  "sig_inst",
  "qual_sig",
  "var_sig",
  "constant_sig",
  "module_sig",
  "fixed_sig",
  0};

Signature copy_Signature(Signature _node) {
  switch (Signature_KEY(_node)) {
    case KEYsig_name:
      return sig_name(
        copy_Symbol(sig_name_name(_node)));
    case KEYno_sig:
      return no_sig();
    case KEYsig_inst:
      return sig_inst(
        copy_Signature(sig_inst_sig(_node)),
        copy_TypeActuals(sig_inst_actuals(_node)));
    case KEYqual_sig:
      return qual_sig(
        copy_Type(qual_sig_inst(_node)),
        copy_Signature(qual_sig_sig(_node)));
    case KEYvar_sig:
      return var_sig(
        copy_Signature(var_sig_sig(_node)));
    case KEYconstant_sig:
      return constant_sig(
        copy_Signature(constant_sig_sig(_node)));
    case KEYmodule_sig:
      return module_sig(
        copy_TypeFormals(module_sig_type_formals(_node)),
        copy_Formals(module_sig_formals(_node)),
        copy_Declaration(module_sig_return_type(_node)));
    case KEYfixed_sig:
      return fixed_sig(
        copy_Types(fixed_sig_types(_node)));
  }
}

void assert_Signature(Signature _node) {
  (void)Signature_KEY(_node);
}

enum KEYTYPE_Type Type_KEY(Type _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Type");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Type",
                         _node,((TNODE)_node)->operator);
    case 11716: return KEYtype_name;
    case 11817: return KEYno_type;
    case 11918: return KEYtype_inst;
    case 12019: return KEYqual_type;
    case 13635: return KEYremote_type;
    case 13736: return KEYordered_set_type;
    case 13837: return KEYset_type;
    case 13938: return KEYlist_type;
    case 14039: return KEYfunction_type;
  }
}
char *Type_constructors[] = {
  "type_name",
  "no_type",
  "type_inst",
  "qual_type",
  "remote_type",
  "ordered_set_type",
  "set_type",
  "list_type",
  "function_type",
  0};

Type copy_Type(Type _node) {
  switch (Type_KEY(_node)) {
    case KEYtype_name:
      return type_name(
        copy_Symbol(type_name_name(_node)));
    case KEYno_type:
      return no_type();
    case KEYtype_inst:
      return type_inst(
        copy_Type(type_inst_base(_node)),
        copy_TypeActuals(type_inst_type_actuals(_node)),
        copy_Actuals(type_inst_actuals(_node)));
    case KEYqual_type:
      return qual_type(
        copy_Type(qual_type_inst(_node)),
        copy_Type(qual_type_type_(_node)));
    case KEYremote_type:
      return remote_type(
        copy_Type(remote_type_nodetype(_node)));
    case KEYordered_set_type:
      return ordered_set_type(
        copy_Type(ordered_set_type_u(_node)),
        copy_Expression(ordered_set_type_equal(_node)),
        copy_Expression(ordered_set_type_order(_node)));
    case KEYset_type:
      return set_type(
        copy_Type(set_type_u(_node)),
        copy_Expression(set_type_equal(_node)));
    case KEYlist_type:
      return list_type(
        copy_Type(list_type_u(_node)));
    case KEYfunction_type:
      return function_type(
        copy_Formals(function_type_formals(_node)),
        copy_Declaration(function_type_return_value(_node)));
  }
}

void assert_Type(Type _node) {
  (void)Type_KEY(_node);
}

enum KEYTYPE_Expression Expression_KEY(Expression _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Expression");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Expression",
                         _node,((TNODE)_node)->operator);
    case 12120: return KEYvalue_name;
    case 12221: return KEYvalue_inst;
    case 12322: return KEYqual_value;
    case 15857: return KEYinteger_const;
    case 15958: return KEYstring_const;
    case 16059: return KEYchar_const;
    case 16160: return KEYundefined;
    case 16261: return KEYno_expr;
    case 16362: return KEYfuncall;
    case 16463: return KEYreduce;
    case 16564: return KEYsequence;
    case 16665: return KEYconstructor_key;
    case 16766: return KEYsignature_value;
    case 16867: return KEYtype_value;
    case 16968: return KEYpattern_value;
    case 17069: return KEYrepeat;
    case 17170: return KEYguarded;
    case 17271: return KEYcontrolled;
  }
}
char *Expression_constructors[] = {
  "value_name",
  "value_inst",
  "qual_value",
  "integer_const",
  "string_const",
  "char_const",
  "undefined",
  "no_expr",
  "funcall",
  "reduce",
  "sequence",
  "constructor_key",
  "signature_value",
  "type_value",
  "pattern_value",
  "repeat",
  "guarded",
  "controlled",
  0};

Expression copy_Expression(Expression _node) {
  switch (Expression_KEY(_node)) {
    case KEYvalue_name:
      return value_name(
        copy_Symbol(value_name_name(_node)));
    case KEYvalue_inst:
      return value_inst(
        copy_Expression(value_inst_base(_node)),
        copy_TypeActuals(value_inst_actuals(_node)));
    case KEYqual_value:
      return qual_value(
        copy_Type(qual_value_inst(_node)),
        copy_Expression(qual_value_value(_node)));
    case KEYinteger_const:
      return integer_const(
        copy_String(integer_const_token(_node)));
    case KEYstring_const:
      return string_const(
        copy_String(string_const_token(_node)));
    case KEYchar_const:
      return char_const(
        copy_String(char_const_token(_node)));
    case KEYundefined:
      return undefined();
    case KEYno_expr:
      return no_expr();
    case KEYfuncall:
      return funcall(
        copy_Expression(funcall_f(_node)),
        copy_Actuals(funcall_actuals(_node)));
    case KEYreduce:
      return reduce(
        copy_Expression(reduce_f(_node)),
        copy_Expressions(reduce_elems(_node)));
    case KEYsequence:
      return sequence(
        copy_Expressions(sequence_elems(_node)),
        copy_Type(sequence_type_(_node)));
    case KEYconstructor_key:
      return constructor_key(
        copy_Expression(constructor_key_name(_node)));
    case KEYsignature_value:
      return signature_value(
        copy_Signature(signature_value_s(_node)));
    case KEYtype_value:
      return type_value(
        copy_Type(type_value_t(_node)));
    case KEYpattern_value:
      return pattern_value(
        copy_Pattern(pattern_value_p(_node)));
    case KEYrepeat:
      return repeat(
        copy_Expression(repeat_expr(_node)));
    case KEYguarded:
      return guarded(
        copy_Expression(guarded_expr(_node)),
        copy_Expression(guarded_cond(_node)));
    case KEYcontrolled:
      return controlled(
        copy_Expression(controlled_expr(_node)),
        copy_ValueDecl(controlled_decl(_node)),
        copy_Expression(controlled_set(_node)));
  }
}

void assert_Expression(Expression _node) {
  (void)Expression_KEY(_node);
}

enum KEYTYPE_Pattern Pattern_KEY(Pattern _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Pattern");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Pattern",
                         _node,((TNODE)_node)->operator);
    case 12827: return KEYpattern_name;
    case 12928: return KEYno_pattern;
    case 13029: return KEYpattern_inst;
    case 13130: return KEYqual_pattern;
    case 14140: return KEYsimple_pattern;
    case 14241: return KEYpattern_actual;
    case 14342: return KEYsequence_pattern;
    case 14443: return KEYrest_pattern;
    case 14544: return KEYchoice_pattern;
    case 14645: return KEYand_pattern;
    case 14746: return KEYpattern_var;
    case 14847: return KEYcondition;
  }
}
char *Pattern_constructors[] = {
  "pattern_name",
  "no_pattern",
  "pattern_inst",
  "qual_pattern",
  "simple_pattern",
  "pattern_actual",
  "sequence_pattern",
  "rest_pattern",
  "choice_pattern",
  "and_pattern",
  "pattern_var",
  "condition",
  0};

Pattern copy_Pattern(Pattern _node) {
  switch (Pattern_KEY(_node)) {
    case KEYpattern_name:
      return pattern_name(
        copy_Symbol(pattern_name_name(_node)));
    case KEYno_pattern:
      return no_pattern();
    case KEYpattern_inst:
      return pattern_inst(
        copy_Pattern(pattern_inst_base(_node)),
        copy_TypeActuals(pattern_inst_actuals(_node)));
    case KEYqual_pattern:
      return qual_pattern(
        copy_Type(qual_pattern_inst(_node)),
        copy_Pattern(qual_pattern_pattern(_node)));
    case KEYsimple_pattern:
      return simple_pattern(
        copy_Pattern(simple_pattern_con(_node)),
        copy_PatternActuals(simple_pattern_actuals(_node)));
    case KEYpattern_actual:
      return pattern_actual(
        copy_Pattern(pattern_actual_arg(_node)),
        copy_Expression(pattern_actual_formal(_node)));
    case KEYsequence_pattern:
      return sequence_pattern(
        copy_Patterns(sequence_pattern_actuals(_node)),
        copy_Type(sequence_pattern_type_(_node)));
    case KEYrest_pattern:
      return rest_pattern(
        copy_Pattern(rest_pattern_constraint(_node)));
    case KEYchoice_pattern:
      return choice_pattern(
        copy_Patterns(choice_pattern_choices(_node)));
    case KEYand_pattern:
      return and_pattern(
        copy_Pattern(and_pattern_p1(_node)),
        copy_Pattern(and_pattern_p2(_node)));
    case KEYpattern_var:
      return pattern_var(
        copy_ValueDecl(pattern_var_as_value(_node)));
    case KEYcondition:
      return condition(
        copy_Expression(condition_e(_node)));
  }
}

void assert_Pattern(Pattern _node) {
  (void)Pattern_KEY(_node);
}

enum KEYTYPE_SignatureDecl SignatureDecl_KEY(SignatureDecl _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type SignatureDecl");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type SignatureDecl",
                         _node,((TNODE)_node)->operator);
    case 11312: return KEYa_signature;
  }
}
char *SignatureDecl_constructors[] = {
  "a_signature",
  0};

SignatureDecl copy_SignatureDecl(SignatureDecl _node) {
  switch (SignatureDecl_KEY(_node)) {
    case KEYa_signature:
      return a_signature(
        copy_Symbol(a_signature_name(_node)),
        copy_TypeFormals(a_signature_type_formals(_node)),
        copy_Boolean(a_signature_constant_(_node)),
        copy_Boolean(a_signature_exported(_node)));
  }
}

void assert_SignatureDecl(SignatureDecl _node) {
  (void)SignatureDecl_KEY(_node);
}

enum KEYTYPE_TypeDecl TypeDecl_KEY(TypeDecl _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type TypeDecl");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type TypeDecl",
                         _node,((TNODE)_node)->operator);
    case 11413: return KEYa_type;
  }
}
char *TypeDecl_constructors[] = {
  "a_type",
  0};

TypeDecl copy_TypeDecl(TypeDecl _node) {
  switch (TypeDecl_KEY(_node)) {
    case KEYa_type:
      return a_type(
        copy_Symbol(a_type_name(_node)),
        copy_TypeFormals(a_type_type_formals(_node)),
        copy_Signatures(a_type_signatures(_node)),
        copy_Boolean(a_type_constant_(_node)),
        copy_Boolean(a_type_exported(_node)));
  }
}

void assert_TypeDecl(TypeDecl _node) {
  (void)TypeDecl_KEY(_node);
}

enum KEYTYPE_ValueDecl ValueDecl_KEY(ValueDecl _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type ValueDecl");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type ValueDecl",
                         _node,((TNODE)_node)->operator);
    case 11514: return KEYa_value;
  }
}
char *ValueDecl_constructors[] = {
  "a_value",
  0};

ValueDecl copy_ValueDecl(ValueDecl _node) {
  switch (ValueDecl_KEY(_node)) {
    case KEYa_value:
      return a_value(
        copy_Symbol(a_value_name(_node)),
        copy_TypeFormals(a_value_type_formals(_node)),
        copy_Type(a_value_type_(_node)),
        copy_Boolean(a_value_constant_(_node)),
        copy_Boolean(a_value_exported(_node)));
  }
}

void assert_ValueDecl(ValueDecl _node) {
  (void)ValueDecl_KEY(_node);
}

enum KEYTYPE_PatternDecl PatternDecl_KEY(PatternDecl _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type PatternDecl");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type PatternDecl",
                         _node,((TNODE)_node)->operator);
    case 11615: return KEYa_pattern;
  }
}
char *PatternDecl_constructors[] = {
  "a_pattern",
  0};

PatternDecl copy_PatternDecl(PatternDecl _node) {
  switch (PatternDecl_KEY(_node)) {
    case KEYa_pattern:
      return a_pattern(
        copy_Symbol(a_pattern_name(_node)),
        copy_TypeFormals(a_pattern_type_formals(_node)),
        copy_Type(a_pattern_type_(_node)),
        copy_Boolean(a_pattern_constant_(_node)),
        copy_Boolean(a_pattern_exported(_node)));
  }
}

void assert_PatternDecl(PatternDecl _node) {
  (void)PatternDecl_KEY(_node);
}

enum KEYTYPE_Program Program_KEY(Program _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Program");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Program",
                         _node,((TNODE)_node)->operator);
    case 7878: return KEYprogram;
  }
}
char *Program_constructors[] = {
  "program",
  0};

Program copy_Program(Program _node) {
  switch (Program_KEY(_node)) {
    case KEYprogram:
      return program(
        copy_Units(program_units(_node)));
  }
}

void assert_Program(Program _node) {
  (void)Program_KEY(_node);
}

enum KEYTYPE_Unit Unit_KEY(Unit _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Unit");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Unit",
                         _node,((TNODE)_node)->operator);
    case 7979: return KEYno_unit;
    case 8080: return KEYwith_unit;
    case 8181: return KEYdecl_unit;
  }
}
char *Unit_constructors[] = {
  "no_unit",
  "with_unit",
  "decl_unit",
  0};

Unit copy_Unit(Unit _node) {
  switch (Unit_KEY(_node)) {
    case KEYno_unit:
      return no_unit();
    case KEYwith_unit:
      return with_unit(
        copy_String(with_unit_name(_node)));
    case KEYdecl_unit:
      return decl_unit(
        copy_Declaration(decl_unit_decl(_node)));
  }
}

void assert_Unit(Unit _node) {
  (void)Unit_KEY(_node);
}

enum KEYTYPE_Declaration Declaration_KEY(Declaration _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Declaration");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Declaration",
                         _node,((TNODE)_node)->operator);
    case 8282: return KEYno_decl;
    case 8383: return KEYmodule_decl;
    case 8484: return KEYsignature_decl;
    case 8585: return KEYphylum_decl;
    case 8686: return KEYconstructor_decl;
    case 8787: return KEYattribute_decl;
    case 8888: return KEYtype_decl;
    case 8989: return KEYfunction_decl;
    case 9090: return KEYprocedure_decl;
    case 9191: return KEYtop_level_match;
    case 9292: return KEYvalue_decl;
    case 9393: return KEYpattern_decl;
    case 9494: return KEYinheritance;
    case 9595: return KEYpragma_decl;
    case 14948: return KEYstmts;
    case 15049: return KEYeffect;
    case 15150: return KEYassign;
    case 15251: return KEYif_stmt;
    case 15352: return KEYfor_in_stmt;
    case 15453: return KEYfor_on_stmt;
    case 15554: return KEYfor_stmt;
    case 15655: return KEYcase_stmt;
  }
}
char *Declaration_constructors[] = {
  "no_decl",
  "module_decl",
  "signature_decl",
  "phylum_decl",
  "constructor_decl",
  "attribute_decl",
  "type_decl",
  "function_decl",
  "procedure_decl",
  "top_level_match",
  "value_decl",
  "pattern_decl",
  "inheritance",
  "pragma_decl",
  "stmts",
  "effect",
  "assign",
  "if_stmt",
  "for_in_stmt",
  "for_on_stmt",
  "for_stmt",
  "case_stmt",
  0};

Declaration copy_Declaration(Declaration _node) {
  switch (Declaration_KEY(_node)) {
    case KEYno_decl:
      return no_decl();
    case KEYmodule_decl:
      return module_decl(
        copy_SignatureDecl(module_decl_as_sig(_node)),
        copy_TypeDecl(module_decl_as_tfunc(_node)),
        copy_Declarations(module_decl_contents(_node)));
    case KEYsignature_decl:
      return signature_decl(
        copy_SignatureDecl(signature_decl_as_sig(_node)),
        copy_Declaration(signature_decl_creating(_node)),
        copy_Declarations(signature_decl_contents(_node)));
    case KEYphylum_decl:
      return phylum_decl(
        copy_TypeDecl(phylum_decl_as_type(_node)),
        copy_Type(phylum_decl_type_(_node)));
    case KEYconstructor_decl:
      return constructor_decl(
        copy_ValueDecl(constructor_decl_as_value(_node)),
        copy_PatternDecl(constructor_decl_as_pattern(_node)),
        copy_Declaration(constructor_decl_body(_node)));
    case KEYattribute_decl:
      return attribute_decl(
        copy_ValueDecl(attribute_decl_as_value(_node)),
        copy_Direction(attribute_decl_direction(_node)),
        copy_Default(attribute_decl_default(_node)));
    case KEYtype_decl:
      return type_decl(
        copy_TypeDecl(type_decl_as_type(_node)),
        copy_Type(type_decl_type_(_node)));
    case KEYfunction_decl:
      return function_decl(
        copy_ValueDecl(function_decl_as_value(_node)),
        copy_Declaration(function_decl_body(_node)));
    case KEYprocedure_decl:
      return procedure_decl(
        copy_ValueDecl(procedure_decl_as_value(_node)),
        copy_Declaration(procedure_decl_body(_node)));
    case KEYtop_level_match:
      return top_level_match(
        copy_Match(top_level_match_m(_node)));
    case KEYvalue_decl:
      return value_decl(
        copy_ValueDecl(value_decl_as_value(_node)),
        copy_Direction(value_decl_direction(_node)),
        copy_Default(value_decl_default(_node)));
    case KEYpattern_decl:
      return pattern_decl(
        copy_PatternDecl(pattern_decl_as_pattern(_node)),
        copy_Pattern(pattern_decl_choices(_node)));
    case KEYinheritance:
      return inheritance(
        copy_Type(inheritance_used(_node)),
        copy_Renamings(inheritance_renamings(_node)));
    case KEYpragma_decl:
      return pragma_decl(
        copy_Symbol(pragma_decl_name(_node)),
        copy_Expressions(pragma_decl_parameters(_node)));
    case KEYstmts:
      return stmts(
        copy_Declarations(stmts_body(_node)));
    case KEYeffect:
      return effect(
        copy_Expression(effect_e(_node)));
    case KEYassign:
      return assign(
        copy_Expression(assign_lhs(_node)),
        copy_Expression(assign_rhs(_node)));
    case KEYif_stmt:
      return if_stmt(
        copy_Expression(if_stmt_cond(_node)),
        copy_Declaration(if_stmt_if_true(_node)),
        copy_Declaration(if_stmt_if_false(_node)));
    case KEYfor_in_stmt:
      return for_in_stmt(
        copy_ValueDecl(for_in_stmt_formal(_node)),
        copy_Expression(for_in_stmt_seq(_node)),
        copy_Declaration(for_in_stmt_body(_node)));
    case KEYfor_on_stmt:
      return for_on_stmt(
        copy_ValueDecl(for_on_stmt_formal(_node)),
        copy_Expression(for_on_stmt_seq(_node)),
        copy_Declaration(for_on_stmt_body(_node)));
    case KEYfor_stmt:
      return for_stmt(
        copy_Expression(for_stmt_expr(_node)),
        copy_Matches(for_stmt_matchers(_node)));
    case KEYcase_stmt:
      return case_stmt(
        copy_Expression(case_stmt_expr(_node)),
        copy_Matches(case_stmt_matchers(_node)),
        copy_Declaration(case_stmt_default(_node)));
  }
}

void assert_Declaration(Declaration _node) {
  (void)Declaration_KEY(_node);
}

enum KEYTYPE_Renaming Renaming_KEY(Renaming _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Renaming");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Renaming",
                         _node,((TNODE)_node)->operator);
    case 9696: return KEYno_renaming;
    case 9797: return KEYsignature_replacement;
    case 9898: return KEYtype_replacement;
    case 9999: return KEYvalue_replacement;
    case 10100: return KEYpattern_replacement;
    case 10201: return KEYsignature_renaming;
    case 10302: return KEYtype_renaming;
    case 10403: return KEYvalue_renaming;
    case 10504: return KEYpattern_renaming;
  }
}
char *Renaming_constructors[] = {
  "no_renaming",
  "signature_replacement",
  "type_replacement",
  "value_replacement",
  "pattern_replacement",
  "signature_renaming",
  "type_renaming",
  "value_renaming",
  "pattern_renaming",
  0};

Renaming copy_Renaming(Renaming _node) {
  switch (Renaming_KEY(_node)) {
    case KEYno_renaming:
      return no_renaming();
    case KEYsignature_replacement:
      return signature_replacement(
        copy_Signature(signature_replacement_old(_node)),
        copy_Signature(signature_replacement_ew(_node)));
    case KEYtype_replacement:
      return type_replacement(
        copy_Type(type_replacement_old(_node)),
        copy_Type(type_replacement_new(_node)));
    case KEYvalue_replacement:
      return value_replacement(
        copy_Expression(value_replacement_old(_node)),
        copy_Expression(value_replacement_new(_node)));
    case KEYpattern_replacement:
      return pattern_replacement(
        copy_Pattern(pattern_replacement_old(_node)),
        copy_Pattern(pattern_replacement_new(_node)));
    case KEYsignature_renaming:
      return signature_renaming(
        copy_SignatureDecl(signature_renaming_decl(_node)),
        copy_Signature(signature_renaming_old(_node)),
        copy_Renamings(signature_renaming_elements(_node)));
    case KEYtype_renaming:
      return type_renaming(
        copy_TypeDecl(type_renaming_decl(_node)),
        copy_Type(type_renaming_old(_node)));
    case KEYvalue_renaming:
      return value_renaming(
        copy_ValueDecl(value_renaming_decl(_node)),
        copy_Expression(value_renaming_old(_node)));
    case KEYpattern_renaming:
      return pattern_renaming(
        copy_PatternDecl(pattern_renaming_decl(_node)),
        copy_Pattern(pattern_renaming_old(_node)));
  }
}

void assert_Renaming(Renaming _node) {
  (void)Renaming_KEY(_node);
}

enum KEYTYPE_Match Match_KEY(Match _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Match");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Match",
                         _node,((TNODE)_node)->operator);
    case 15756: return KEYmatcher;
  }
}
char *Match_constructors[] = {
  "matcher",
  0};

Match copy_Match(Match _node) {
  switch (Match_KEY(_node)) {
    case KEYmatcher:
      return matcher(
        copy_TypeFormals(matcher_polymorphism(_node)),
        copy_Pattern(matcher_pat(_node)),
        copy_Declaration(matcher_stmt(_node)));
  }
}

void assert_Match(Match _node) {
  (void)Match_KEY(_node);
}

enum KEYTYPE_Direction Direction_KEY(Direction _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Direction");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Direction",
                         _node,((TNODE)_node)->operator);
    case 10605: return KEYno_direction;
    case 10706: return KEYcollection_;
    case 10807: return KEYcircular_;
  }
}
char *Direction_constructors[] = {
  "no_direction",
  "collection_",
  "circular_",
  0};

Direction copy_Direction(Direction _node) {
  switch (Direction_KEY(_node)) {
    case KEYno_direction:
      return no_direction(
        copy_Boolean(no_direction_is_input(_node)));
    case KEYcollection_:
      return collection_(
        copy_Boolean(collection__is_input(_node)));
    case KEYcircular_:
      return circular_(
        copy_Boolean(circular__is_input(_node)));
  }
}

void assert_Direction(Direction _node) {
  (void)Direction_KEY(_node);
}

enum KEYTYPE_Default Default_KEY(Default _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Default");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Default",
                         _node,((TNODE)_node)->operator);
    case 10908: return KEYsimple;
    case 11009: return KEYcomposite;
    case 11110: return KEYlattice;
    case 11211: return KEYno_default;
  }
}
char *Default_constructors[] = {
  "simple",
  "composite",
  "lattice",
  "no_default",
  0};

Default copy_Default(Default _node) {
  switch (Default_KEY(_node)) {
    case KEYsimple:
      return simple(
        copy_Expression(simple_value(_node)));
    case KEYcomposite:
      return composite(
        copy_Expression(composite_initial(_node)),
        copy_Expression(composite_combiner(_node)));
    case KEYlattice:
      return lattice(
        copy_Expression(lattice_bottom(_node)),
        copy_Expression(lattice_join(_node)),
        copy_Expression(lattice_equal(_node)));
    case KEYno_default:
      return no_default();
  }
}

void assert_Default(Default _node) {
  (void)Default_KEY(_node);
}

enum KEYTYPE_Units Units_KEY(Units _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Units");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Units",
                         _node,((TNODE)_node)->operator);
    case 2727: return KEYnil_Units;
    case 2828: return KEYlist_Units;
    case 2929: return KEYappend_Units;
  }
}
char *Units_constructors[] = {
  "nil_Units",
  "list_Units",
  "append_Units",
  0};

Units copy_Units(Units _node) {
  switch (Units_KEY(_node)) {
    case KEYnil_Units:
      return nil_Units();
    case KEYlist_Units:
      return list_Units(
        copy_Unit(list_Units_elem(_node)));
    case KEYappend_Units:
      return append_Units(
        copy_Units(append_Units_l1(_node)),
        copy_Units(append_Units_l2(_node)));
  }
}

void assert_Units(Units _node) {
  (void)Units_KEY(_node);
}

/* Constructor function */
Units nil_Units(){
  TNODE _node = create_tnode(2727,0);
  return (Units)_node;
}
/* Accessors */

/* Constructor function */
Units list_Units(Unit elem){
  TNODE _node = create_tnode(2828,1);
  assert_Unit(elem);
  _node->children[0] = (void *)elem;
  return (Units)_node;
}
/* Accessors */
Unit list_Units_elem(Units _node){
  if (Units_KEY(_node) != KEYlist_Units) {
    fatal_error("list_Units_elem: called with %s",
                Units_constructors[Units_KEY(_node)]);
  }
  return (Unit)((TNODE)_node)->children[0];
}

/* Constructor function */
Units append_Units(Units l1,Units l2){
  TNODE _node = create_tnode(2929,2);
  assert_Units(l1);
  _node->children[0] = (void *)l1;
  assert_Units(l2);
  _node->children[1] = (void *)l2;
  return (Units)_node;
}
/* Accessors */
Units append_Units_l1(Units _node){
  if (Units_KEY(_node) != KEYappend_Units) {
    fatal_error("append_Units_l1: called with %s",
                Units_constructors[Units_KEY(_node)]);
  }
  return (Units)((TNODE)_node)->children[0];
}
Units append_Units_l2(Units _node){
  if (Units_KEY(_node) != KEYappend_Units) {
    fatal_error("append_Units_l2: called with %s",
                Units_constructors[Units_KEY(_node)]);
  }
  return (Units)((TNODE)_node)->children[1];
}

enum KEYTYPE_Declarations Declarations_KEY(Declarations _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Declarations");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Declarations",
                         _node,((TNODE)_node)->operator);
    case 3131: return KEYnil_Declarations;
    case 3232: return KEYlist_Declarations;
    case 3333: return KEYappend_Declarations;
  }
}
char *Declarations_constructors[] = {
  "nil_Declarations",
  "list_Declarations",
  "append_Declarations",
  0};

Declarations copy_Declarations(Declarations _node) {
  switch (Declarations_KEY(_node)) {
    case KEYnil_Declarations:
      return nil_Declarations();
    case KEYlist_Declarations:
      return list_Declarations(
        copy_Declaration(list_Declarations_elem(_node)));
    case KEYappend_Declarations:
      return append_Declarations(
        copy_Declarations(append_Declarations_l1(_node)),
        copy_Declarations(append_Declarations_l2(_node)));
  }
}

void assert_Declarations(Declarations _node) {
  (void)Declarations_KEY(_node);
}

/* Constructor function */
Declarations nil_Declarations(){
  TNODE _node = create_tnode(3131,0);
  return (Declarations)_node;
}
/* Accessors */

/* Constructor function */
Declarations list_Declarations(Declaration elem){
  TNODE _node = create_tnode(3232,1);
  assert_Declaration(elem);
  _node->children[0] = (void *)elem;
  return (Declarations)_node;
}
/* Accessors */
Declaration list_Declarations_elem(Declarations _node){
  if (Declarations_KEY(_node) != KEYlist_Declarations) {
    fatal_error("list_Declarations_elem: called with %s",
                Declarations_constructors[Declarations_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[0];
}

/* Constructor function */
Declarations append_Declarations(Declarations l1,Declarations l2){
  TNODE _node = create_tnode(3333,2);
  assert_Declarations(l1);
  _node->children[0] = (void *)l1;
  assert_Declarations(l2);
  _node->children[1] = (void *)l2;
  return (Declarations)_node;
}
/* Accessors */
Declarations append_Declarations_l1(Declarations _node){
  if (Declarations_KEY(_node) != KEYappend_Declarations) {
    fatal_error("append_Declarations_l1: called with %s",
                Declarations_constructors[Declarations_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[0];
}
Declarations append_Declarations_l2(Declarations _node){
  if (Declarations_KEY(_node) != KEYappend_Declarations) {
    fatal_error("append_Declarations_l2: called with %s",
                Declarations_constructors[Declarations_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[1];
}

enum KEYTYPE_Matches Matches_KEY(Matches _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Matches");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Matches",
                         _node,((TNODE)_node)->operator);
    case 3535: return KEYnil_Matches;
    case 3636: return KEYlist_Matches;
    case 3737: return KEYappend_Matches;
  }
}
char *Matches_constructors[] = {
  "nil_Matches",
  "list_Matches",
  "append_Matches",
  0};

Matches copy_Matches(Matches _node) {
  switch (Matches_KEY(_node)) {
    case KEYnil_Matches:
      return nil_Matches();
    case KEYlist_Matches:
      return list_Matches(
        copy_Match(list_Matches_elem(_node)));
    case KEYappend_Matches:
      return append_Matches(
        copy_Matches(append_Matches_l1(_node)),
        copy_Matches(append_Matches_l2(_node)));
  }
}

void assert_Matches(Matches _node) {
  (void)Matches_KEY(_node);
}

/* Constructor function */
Matches nil_Matches(){
  TNODE _node = create_tnode(3535,0);
  return (Matches)_node;
}
/* Accessors */

/* Constructor function */
Matches list_Matches(Match elem){
  TNODE _node = create_tnode(3636,1);
  assert_Match(elem);
  _node->children[0] = (void *)elem;
  return (Matches)_node;
}
/* Accessors */
Match list_Matches_elem(Matches _node){
  if (Matches_KEY(_node) != KEYlist_Matches) {
    fatal_error("list_Matches_elem: called with %s",
                Matches_constructors[Matches_KEY(_node)]);
  }
  return (Match)((TNODE)_node)->children[0];
}

/* Constructor function */
Matches append_Matches(Matches l1,Matches l2){
  TNODE _node = create_tnode(3737,2);
  assert_Matches(l1);
  _node->children[0] = (void *)l1;
  assert_Matches(l2);
  _node->children[1] = (void *)l2;
  return (Matches)_node;
}
/* Accessors */
Matches append_Matches_l1(Matches _node){
  if (Matches_KEY(_node) != KEYappend_Matches) {
    fatal_error("append_Matches_l1: called with %s",
                Matches_constructors[Matches_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[0];
}
Matches append_Matches_l2(Matches _node){
  if (Matches_KEY(_node) != KEYappend_Matches) {
    fatal_error("append_Matches_l2: called with %s",
                Matches_constructors[Matches_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[1];
}

enum KEYTYPE_Renamings Renamings_KEY(Renamings _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Renamings");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Renamings",
                         _node,((TNODE)_node)->operator);
    case 3939: return KEYnil_Renamings;
    case 4040: return KEYlist_Renamings;
    case 4141: return KEYappend_Renamings;
  }
}
char *Renamings_constructors[] = {
  "nil_Renamings",
  "list_Renamings",
  "append_Renamings",
  0};

Renamings copy_Renamings(Renamings _node) {
  switch (Renamings_KEY(_node)) {
    case KEYnil_Renamings:
      return nil_Renamings();
    case KEYlist_Renamings:
      return list_Renamings(
        copy_Renaming(list_Renamings_elem(_node)));
    case KEYappend_Renamings:
      return append_Renamings(
        copy_Renamings(append_Renamings_l1(_node)),
        copy_Renamings(append_Renamings_l2(_node)));
  }
}

void assert_Renamings(Renamings _node) {
  (void)Renamings_KEY(_node);
}

/* Constructor function */
Renamings nil_Renamings(){
  TNODE _node = create_tnode(3939,0);
  return (Renamings)_node;
}
/* Accessors */

/* Constructor function */
Renamings list_Renamings(Renaming elem){
  TNODE _node = create_tnode(4040,1);
  assert_Renaming(elem);
  _node->children[0] = (void *)elem;
  return (Renamings)_node;
}
/* Accessors */
Renaming list_Renamings_elem(Renamings _node){
  if (Renamings_KEY(_node) != KEYlist_Renamings) {
    fatal_error("list_Renamings_elem: called with %s",
                Renamings_constructors[Renamings_KEY(_node)]);
  }
  return (Renaming)((TNODE)_node)->children[0];
}

/* Constructor function */
Renamings append_Renamings(Renamings l1,Renamings l2){
  TNODE _node = create_tnode(4141,2);
  assert_Renamings(l1);
  _node->children[0] = (void *)l1;
  assert_Renamings(l2);
  _node->children[1] = (void *)l2;
  return (Renamings)_node;
}
/* Accessors */
Renamings append_Renamings_l1(Renamings _node){
  if (Renamings_KEY(_node) != KEYappend_Renamings) {
    fatal_error("append_Renamings_l1: called with %s",
                Renamings_constructors[Renamings_KEY(_node)]);
  }
  return (Renamings)((TNODE)_node)->children[0];
}
Renamings append_Renamings_l2(Renamings _node){
  if (Renamings_KEY(_node) != KEYappend_Renamings) {
    fatal_error("append_Renamings_l2: called with %s",
                Renamings_constructors[Renamings_KEY(_node)]);
  }
  return (Renamings)((TNODE)_node)->children[1];
}

enum KEYTYPE_Signatures Signatures_KEY(Signatures _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Signatures");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Signatures",
                         _node,((TNODE)_node)->operator);
    case 4343: return KEYnil_Signatures;
    case 4444: return KEYlist_Signatures;
    case 4545: return KEYappend_Signatures;
  }
}
char *Signatures_constructors[] = {
  "nil_Signatures",
  "list_Signatures",
  "append_Signatures",
  0};

Signatures copy_Signatures(Signatures _node) {
  switch (Signatures_KEY(_node)) {
    case KEYnil_Signatures:
      return nil_Signatures();
    case KEYlist_Signatures:
      return list_Signatures(
        copy_Signature(list_Signatures_elem(_node)));
    case KEYappend_Signatures:
      return append_Signatures(
        copy_Signatures(append_Signatures_l1(_node)),
        copy_Signatures(append_Signatures_l2(_node)));
  }
}

void assert_Signatures(Signatures _node) {
  (void)Signatures_KEY(_node);
}

/* Constructor function */
Signatures nil_Signatures(){
  TNODE _node = create_tnode(4343,0);
  return (Signatures)_node;
}
/* Accessors */

/* Constructor function */
Signatures list_Signatures(Signature elem){
  TNODE _node = create_tnode(4444,1);
  assert_Signature(elem);
  _node->children[0] = (void *)elem;
  return (Signatures)_node;
}
/* Accessors */
Signature list_Signatures_elem(Signatures _node){
  if (Signatures_KEY(_node) != KEYlist_Signatures) {
    fatal_error("list_Signatures_elem: called with %s",
                Signatures_constructors[Signatures_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}

/* Constructor function */
Signatures append_Signatures(Signatures l1,Signatures l2){
  TNODE _node = create_tnode(4545,2);
  assert_Signatures(l1);
  _node->children[0] = (void *)l1;
  assert_Signatures(l2);
  _node->children[1] = (void *)l2;
  return (Signatures)_node;
}
/* Accessors */
Signatures append_Signatures_l1(Signatures _node){
  if (Signatures_KEY(_node) != KEYappend_Signatures) {
    fatal_error("append_Signatures_l1: called with %s",
                Signatures_constructors[Signatures_KEY(_node)]);
  }
  return (Signatures)((TNODE)_node)->children[0];
}
Signatures append_Signatures_l2(Signatures _node){
  if (Signatures_KEY(_node) != KEYappend_Signatures) {
    fatal_error("append_Signatures_l2: called with %s",
                Signatures_constructors[Signatures_KEY(_node)]);
  }
  return (Signatures)((TNODE)_node)->children[1];
}

enum KEYTYPE_Types Types_KEY(Types _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Types");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Types",
                         _node,((TNODE)_node)->operator);
    case 4747: return KEYnil_Types;
    case 4848: return KEYlist_Types;
    case 4949: return KEYappend_Types;
  }
}
char *Types_constructors[] = {
  "nil_Types",
  "list_Types",
  "append_Types",
  0};

Types copy_Types(Types _node) {
  switch (Types_KEY(_node)) {
    case KEYnil_Types:
      return nil_Types();
    case KEYlist_Types:
      return list_Types(
        copy_Type(list_Types_elem(_node)));
    case KEYappend_Types:
      return append_Types(
        copy_Types(append_Types_l1(_node)),
        copy_Types(append_Types_l2(_node)));
  }
}

void assert_Types(Types _node) {
  (void)Types_KEY(_node);
}

/* Constructor function */
Types nil_Types(){
  TNODE _node = create_tnode(4747,0);
  return (Types)_node;
}
/* Accessors */

/* Constructor function */
Types list_Types(Type elem){
  TNODE _node = create_tnode(4848,1);
  assert_Type(elem);
  _node->children[0] = (void *)elem;
  return (Types)_node;
}
/* Accessors */
Type list_Types_elem(Types _node){
  if (Types_KEY(_node) != KEYlist_Types) {
    fatal_error("list_Types_elem: called with %s",
                Types_constructors[Types_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Types append_Types(Types l1,Types l2){
  TNODE _node = create_tnode(4949,2);
  assert_Types(l1);
  _node->children[0] = (void *)l1;
  assert_Types(l2);
  _node->children[1] = (void *)l2;
  return (Types)_node;
}
/* Accessors */
Types append_Types_l1(Types _node){
  if (Types_KEY(_node) != KEYappend_Types) {
    fatal_error("append_Types_l1: called with %s",
                Types_constructors[Types_KEY(_node)]);
  }
  return (Types)((TNODE)_node)->children[0];
}
Types append_Types_l2(Types _node){
  if (Types_KEY(_node) != KEYappend_Types) {
    fatal_error("append_Types_l2: called with %s",
                Types_constructors[Types_KEY(_node)]);
  }
  return (Types)((TNODE)_node)->children[1];
}

enum KEYTYPE_Expressions Expressions_KEY(Expressions _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Expressions");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Expressions",
                         _node,((TNODE)_node)->operator);
    case 5151: return KEYnil_Expressions;
    case 5252: return KEYlist_Expressions;
    case 5353: return KEYappend_Expressions;
  }
}
char *Expressions_constructors[] = {
  "nil_Expressions",
  "list_Expressions",
  "append_Expressions",
  0};

Expressions copy_Expressions(Expressions _node) {
  switch (Expressions_KEY(_node)) {
    case KEYnil_Expressions:
      return nil_Expressions();
    case KEYlist_Expressions:
      return list_Expressions(
        copy_Expression(list_Expressions_elem(_node)));
    case KEYappend_Expressions:
      return append_Expressions(
        copy_Expressions(append_Expressions_l1(_node)),
        copy_Expressions(append_Expressions_l2(_node)));
  }
}

void assert_Expressions(Expressions _node) {
  (void)Expressions_KEY(_node);
}

/* Constructor function */
Expressions nil_Expressions(){
  TNODE _node = create_tnode(5151,0);
  return (Expressions)_node;
}
/* Accessors */

/* Constructor function */
Expressions list_Expressions(Expression elem){
  TNODE _node = create_tnode(5252,1);
  assert_Expression(elem);
  _node->children[0] = (void *)elem;
  return (Expressions)_node;
}
/* Accessors */
Expression list_Expressions_elem(Expressions _node){
  if (Expressions_KEY(_node) != KEYlist_Expressions) {
    fatal_error("list_Expressions_elem: called with %s",
                Expressions_constructors[Expressions_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Expressions append_Expressions(Expressions l1,Expressions l2){
  TNODE _node = create_tnode(5353,2);
  assert_Expressions(l1);
  _node->children[0] = (void *)l1;
  assert_Expressions(l2);
  _node->children[1] = (void *)l2;
  return (Expressions)_node;
}
/* Accessors */
Expressions append_Expressions_l1(Expressions _node){
  if (Expressions_KEY(_node) != KEYappend_Expressions) {
    fatal_error("append_Expressions_l1: called with %s",
                Expressions_constructors[Expressions_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[0];
}
Expressions append_Expressions_l2(Expressions _node){
  if (Expressions_KEY(_node) != KEYappend_Expressions) {
    fatal_error("append_Expressions_l2: called with %s",
                Expressions_constructors[Expressions_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[1];
}

enum KEYTYPE_Patterns Patterns_KEY(Patterns _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Patterns");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Patterns",
                         _node,((TNODE)_node)->operator);
    case 5555: return KEYnil_Patterns;
    case 5656: return KEYlist_Patterns;
    case 5757: return KEYappend_Patterns;
  }
}
char *Patterns_constructors[] = {
  "nil_Patterns",
  "list_Patterns",
  "append_Patterns",
  0};

Patterns copy_Patterns(Patterns _node) {
  switch (Patterns_KEY(_node)) {
    case KEYnil_Patterns:
      return nil_Patterns();
    case KEYlist_Patterns:
      return list_Patterns(
        copy_Pattern(list_Patterns_elem(_node)));
    case KEYappend_Patterns:
      return append_Patterns(
        copy_Patterns(append_Patterns_l1(_node)),
        copy_Patterns(append_Patterns_l2(_node)));
  }
}

void assert_Patterns(Patterns _node) {
  (void)Patterns_KEY(_node);
}

/* Constructor function */
Patterns nil_Patterns(){
  TNODE _node = create_tnode(5555,0);
  return (Patterns)_node;
}
/* Accessors */

/* Constructor function */
Patterns list_Patterns(Pattern elem){
  TNODE _node = create_tnode(5656,1);
  assert_Pattern(elem);
  _node->children[0] = (void *)elem;
  return (Patterns)_node;
}
/* Accessors */
Pattern list_Patterns_elem(Patterns _node){
  if (Patterns_KEY(_node) != KEYlist_Patterns) {
    fatal_error("list_Patterns_elem: called with %s",
                Patterns_constructors[Patterns_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
Patterns append_Patterns(Patterns l1,Patterns l2){
  TNODE _node = create_tnode(5757,2);
  assert_Patterns(l1);
  _node->children[0] = (void *)l1;
  assert_Patterns(l2);
  _node->children[1] = (void *)l2;
  return (Patterns)_node;
}
/* Accessors */
Patterns append_Patterns_l1(Patterns _node){
  if (Patterns_KEY(_node) != KEYappend_Patterns) {
    fatal_error("append_Patterns_l1: called with %s",
                Patterns_constructors[Patterns_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[0];
}
Patterns append_Patterns_l2(Patterns _node){
  if (Patterns_KEY(_node) != KEYappend_Patterns) {
    fatal_error("append_Patterns_l2: called with %s",
                Patterns_constructors[Patterns_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[1];
}

enum KEYTYPE_Formals Formals_KEY(Formals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Formals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Formals",
                         _node,((TNODE)_node)->operator);
    case 5959: return KEYnil_Formals;
    case 6060: return KEYlist_Formals;
    case 6161: return KEYappend_Formals;
  }
}
char *Formals_constructors[] = {
  "nil_Formals",
  "list_Formals",
  "append_Formals",
  0};

Formals copy_Formals(Formals _node) {
  switch (Formals_KEY(_node)) {
    case KEYnil_Formals:
      return nil_Formals();
    case KEYlist_Formals:
      return list_Formals(
        copy_ValueDecl(list_Formals_elem(_node)));
    case KEYappend_Formals:
      return append_Formals(
        copy_Formals(append_Formals_l1(_node)),
        copy_Formals(append_Formals_l2(_node)));
  }
}

void assert_Formals(Formals _node) {
  (void)Formals_KEY(_node);
}

/* Constructor function */
Formals nil_Formals(){
  TNODE _node = create_tnode(5959,0);
  return (Formals)_node;
}
/* Accessors */

/* Constructor function */
Formals list_Formals(ValueDecl elem){
  TNODE _node = create_tnode(6060,1);
  assert_ValueDecl(elem);
  _node->children[0] = (void *)elem;
  return (Formals)_node;
}
/* Accessors */
ValueDecl list_Formals_elem(Formals _node){
  if (Formals_KEY(_node) != KEYlist_Formals) {
    fatal_error("list_Formals_elem: called with %s",
                Formals_constructors[Formals_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}

/* Constructor function */
Formals append_Formals(Formals l1,Formals l2){
  TNODE _node = create_tnode(6161,2);
  assert_Formals(l1);
  _node->children[0] = (void *)l1;
  assert_Formals(l2);
  _node->children[1] = (void *)l2;
  return (Formals)_node;
}
/* Accessors */
Formals append_Formals_l1(Formals _node){
  if (Formals_KEY(_node) != KEYappend_Formals) {
    fatal_error("append_Formals_l1: called with %s",
                Formals_constructors[Formals_KEY(_node)]);
  }
  return (Formals)((TNODE)_node)->children[0];
}
Formals append_Formals_l2(Formals _node){
  if (Formals_KEY(_node) != KEYappend_Formals) {
    fatal_error("append_Formals_l2: called with %s",
                Formals_constructors[Formals_KEY(_node)]);
  }
  return (Formals)((TNODE)_node)->children[1];
}

enum KEYTYPE_TypeFormals TypeFormals_KEY(TypeFormals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type TypeFormals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type TypeFormals",
                         _node,((TNODE)_node)->operator);
    case 6363: return KEYnil_TypeFormals;
    case 6464: return KEYlist_TypeFormals;
    case 6565: return KEYappend_TypeFormals;
  }
}
char *TypeFormals_constructors[] = {
  "nil_TypeFormals",
  "list_TypeFormals",
  "append_TypeFormals",
  0};

TypeFormals copy_TypeFormals(TypeFormals _node) {
  switch (TypeFormals_KEY(_node)) {
    case KEYnil_TypeFormals:
      return nil_TypeFormals();
    case KEYlist_TypeFormals:
      return list_TypeFormals(
        copy_TypeDecl(list_TypeFormals_elem(_node)));
    case KEYappend_TypeFormals:
      return append_TypeFormals(
        copy_TypeFormals(append_TypeFormals_l1(_node)),
        copy_TypeFormals(append_TypeFormals_l2(_node)));
  }
}

void assert_TypeFormals(TypeFormals _node) {
  (void)TypeFormals_KEY(_node);
}

/* Constructor function */
TypeFormals nil_TypeFormals(){
  TNODE _node = create_tnode(6363,0);
  return (TypeFormals)_node;
}
/* Accessors */

/* Constructor function */
TypeFormals list_TypeFormals(TypeDecl elem){
  TNODE _node = create_tnode(6464,1);
  assert_TypeDecl(elem);
  _node->children[0] = (void *)elem;
  return (TypeFormals)_node;
}
/* Accessors */
TypeDecl list_TypeFormals_elem(TypeFormals _node){
  if (TypeFormals_KEY(_node) != KEYlist_TypeFormals) {
    fatal_error("list_TypeFormals_elem: called with %s",
                TypeFormals_constructors[TypeFormals_KEY(_node)]);
  }
  return (TypeDecl)((TNODE)_node)->children[0];
}

/* Constructor function */
TypeFormals append_TypeFormals(TypeFormals l1,TypeFormals l2){
  TNODE _node = create_tnode(6565,2);
  assert_TypeFormals(l1);
  _node->children[0] = (void *)l1;
  assert_TypeFormals(l2);
  _node->children[1] = (void *)l2;
  return (TypeFormals)_node;
}
/* Accessors */
TypeFormals append_TypeFormals_l1(TypeFormals _node){
  if (TypeFormals_KEY(_node) != KEYappend_TypeFormals) {
    fatal_error("append_TypeFormals_l1: called with %s",
                TypeFormals_constructors[TypeFormals_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[0];
}
TypeFormals append_TypeFormals_l2(TypeFormals _node){
  if (TypeFormals_KEY(_node) != KEYappend_TypeFormals) {
    fatal_error("append_TypeFormals_l2: called with %s",
                TypeFormals_constructors[TypeFormals_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[1];
}

enum KEYTYPE_Actuals Actuals_KEY(Actuals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type Actuals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type Actuals",
                         _node,((TNODE)_node)->operator);
    case 6767: return KEYnil_Actuals;
    case 6868: return KEYlist_Actuals;
    case 6969: return KEYappend_Actuals;
  }
}
char *Actuals_constructors[] = {
  "nil_Actuals",
  "list_Actuals",
  "append_Actuals",
  0};

Actuals copy_Actuals(Actuals _node) {
  switch (Actuals_KEY(_node)) {
    case KEYnil_Actuals:
      return nil_Actuals();
    case KEYlist_Actuals:
      return list_Actuals(
        copy_Expression(list_Actuals_elem(_node)));
    case KEYappend_Actuals:
      return append_Actuals(
        copy_Actuals(append_Actuals_l1(_node)),
        copy_Actuals(append_Actuals_l2(_node)));
  }
}

void assert_Actuals(Actuals _node) {
  (void)Actuals_KEY(_node);
}

/* Constructor function */
Actuals nil_Actuals(){
  TNODE _node = create_tnode(6767,0);
  return (Actuals)_node;
}
/* Accessors */

/* Constructor function */
Actuals list_Actuals(Expression elem){
  TNODE _node = create_tnode(6868,1);
  assert_Expression(elem);
  _node->children[0] = (void *)elem;
  return (Actuals)_node;
}
/* Accessors */
Expression list_Actuals_elem(Actuals _node){
  if (Actuals_KEY(_node) != KEYlist_Actuals) {
    fatal_error("list_Actuals_elem: called with %s",
                Actuals_constructors[Actuals_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Actuals append_Actuals(Actuals l1,Actuals l2){
  TNODE _node = create_tnode(6969,2);
  assert_Actuals(l1);
  _node->children[0] = (void *)l1;
  assert_Actuals(l2);
  _node->children[1] = (void *)l2;
  return (Actuals)_node;
}
/* Accessors */
Actuals append_Actuals_l1(Actuals _node){
  if (Actuals_KEY(_node) != KEYappend_Actuals) {
    fatal_error("append_Actuals_l1: called with %s",
                Actuals_constructors[Actuals_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[0];
}
Actuals append_Actuals_l2(Actuals _node){
  if (Actuals_KEY(_node) != KEYappend_Actuals) {
    fatal_error("append_Actuals_l2: called with %s",
                Actuals_constructors[Actuals_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[1];
}

enum KEYTYPE_TypeActuals TypeActuals_KEY(TypeActuals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type TypeActuals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type TypeActuals",
                         _node,((TNODE)_node)->operator);
    case 7171: return KEYnil_TypeActuals;
    case 7272: return KEYlist_TypeActuals;
    case 7373: return KEYappend_TypeActuals;
  }
}
char *TypeActuals_constructors[] = {
  "nil_TypeActuals",
  "list_TypeActuals",
  "append_TypeActuals",
  0};

TypeActuals copy_TypeActuals(TypeActuals _node) {
  switch (TypeActuals_KEY(_node)) {
    case KEYnil_TypeActuals:
      return nil_TypeActuals();
    case KEYlist_TypeActuals:
      return list_TypeActuals(
        copy_Type(list_TypeActuals_elem(_node)));
    case KEYappend_TypeActuals:
      return append_TypeActuals(
        copy_TypeActuals(append_TypeActuals_l1(_node)),
        copy_TypeActuals(append_TypeActuals_l2(_node)));
  }
}

void assert_TypeActuals(TypeActuals _node) {
  (void)TypeActuals_KEY(_node);
}

/* Constructor function */
TypeActuals nil_TypeActuals(){
  TNODE _node = create_tnode(7171,0);
  return (TypeActuals)_node;
}
/* Accessors */

/* Constructor function */
TypeActuals list_TypeActuals(Type elem){
  TNODE _node = create_tnode(7272,1);
  assert_Type(elem);
  _node->children[0] = (void *)elem;
  return (TypeActuals)_node;
}
/* Accessors */
Type list_TypeActuals_elem(TypeActuals _node){
  if (TypeActuals_KEY(_node) != KEYlist_TypeActuals) {
    fatal_error("list_TypeActuals_elem: called with %s",
                TypeActuals_constructors[TypeActuals_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
TypeActuals append_TypeActuals(TypeActuals l1,TypeActuals l2){
  TNODE _node = create_tnode(7373,2);
  assert_TypeActuals(l1);
  _node->children[0] = (void *)l1;
  assert_TypeActuals(l2);
  _node->children[1] = (void *)l2;
  return (TypeActuals)_node;
}
/* Accessors */
TypeActuals append_TypeActuals_l1(TypeActuals _node){
  if (TypeActuals_KEY(_node) != KEYappend_TypeActuals) {
    fatal_error("append_TypeActuals_l1: called with %s",
                TypeActuals_constructors[TypeActuals_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[0];
}
TypeActuals append_TypeActuals_l2(TypeActuals _node){
  if (TypeActuals_KEY(_node) != KEYappend_TypeActuals) {
    fatal_error("append_TypeActuals_l2: called with %s",
                TypeActuals_constructors[TypeActuals_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}

enum KEYTYPE_PatternActuals PatternActuals_KEY(PatternActuals _node){
  if (_node == NULL) {
    fatal_error("NULL is not of type PatternActuals");
  }
  switch(((TNODE)_node)->operator) {
    default: fatal_error("0x%x (code %d) is not of type PatternActuals",
                         _node,((TNODE)_node)->operator);
    case 7575: return KEYnil_PatternActuals;
    case 7676: return KEYlist_PatternActuals;
    case 7777: return KEYappend_PatternActuals;
  }
}
char *PatternActuals_constructors[] = {
  "nil_PatternActuals",
  "list_PatternActuals",
  "append_PatternActuals",
  0};

PatternActuals copy_PatternActuals(PatternActuals _node) {
  switch (PatternActuals_KEY(_node)) {
    case KEYnil_PatternActuals:
      return nil_PatternActuals();
    case KEYlist_PatternActuals:
      return list_PatternActuals(
        copy_Pattern(list_PatternActuals_elem(_node)));
    case KEYappend_PatternActuals:
      return append_PatternActuals(
        copy_PatternActuals(append_PatternActuals_l1(_node)),
        copy_PatternActuals(append_PatternActuals_l2(_node)));
  }
}

void assert_PatternActuals(PatternActuals _node) {
  (void)PatternActuals_KEY(_node);
}

/* Constructor function */
PatternActuals nil_PatternActuals(){
  TNODE _node = create_tnode(7575,0);
  return (PatternActuals)_node;
}
/* Accessors */

/* Constructor function */
PatternActuals list_PatternActuals(Pattern elem){
  TNODE _node = create_tnode(7676,1);
  assert_Pattern(elem);
  _node->children[0] = (void *)elem;
  return (PatternActuals)_node;
}
/* Accessors */
Pattern list_PatternActuals_elem(PatternActuals _node){
  if (PatternActuals_KEY(_node) != KEYlist_PatternActuals) {
    fatal_error("list_PatternActuals_elem: called with %s",
                PatternActuals_constructors[PatternActuals_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
PatternActuals append_PatternActuals(PatternActuals l1,PatternActuals l2){
  TNODE _node = create_tnode(7777,2);
  assert_PatternActuals(l1);
  _node->children[0] = (void *)l1;
  assert_PatternActuals(l2);
  _node->children[1] = (void *)l2;
  return (PatternActuals)_node;
}
/* Accessors */
PatternActuals append_PatternActuals_l1(PatternActuals _node){
  if (PatternActuals_KEY(_node) != KEYappend_PatternActuals) {
    fatal_error("append_PatternActuals_l1: called with %s",
                PatternActuals_constructors[PatternActuals_KEY(_node)]);
  }
  return (PatternActuals)((TNODE)_node)->children[0];
}
PatternActuals append_PatternActuals_l2(PatternActuals _node){
  if (PatternActuals_KEY(_node) != KEYappend_PatternActuals) {
    fatal_error("append_PatternActuals_l2: called with %s",
                PatternActuals_constructors[PatternActuals_KEY(_node)]);
  }
  return (PatternActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Program program(Units units){
  TNODE _node = create_tnode(7878,1);
  assert_Units(units);
  _node->children[0] = (void *)units;
  return (Program)_node;
}
/* Accessors */
Units program_units(Program _node){
  if (Program_KEY(_node) != KEYprogram) {
    fatal_error("program_units: called with %s",
                Program_constructors[Program_KEY(_node)]);
  }
  return (Units)((TNODE)_node)->children[0];
}

/* Constructor function */
Unit no_unit(){
  TNODE _node = create_tnode(7979,0);
  return (Unit)_node;
}
/* Accessors */

/* Constructor function */
Unit with_unit(String name){
  TNODE _node = create_tnode(8080,1);
  assert_String(name);
  _node->children[0] = (void *)name;
  return (Unit)_node;
}
/* Accessors */
String with_unit_name(Unit _node){
  if (Unit_KEY(_node) != KEYwith_unit) {
    fatal_error("with_unit_name: called with %s",
                Unit_constructors[Unit_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Unit decl_unit(Declaration decl){
  TNODE _node = create_tnode(8181,1);
  assert_Declaration(decl);
  _node->children[0] = (void *)decl;
  return (Unit)_node;
}
/* Accessors */
Declaration decl_unit_decl(Unit _node){
  if (Unit_KEY(_node) != KEYdecl_unit) {
    fatal_error("decl_unit_decl: called with %s",
                Unit_constructors[Unit_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration no_decl(){
  TNODE _node = create_tnode(8282,0);
  return (Declaration)_node;
}
/* Accessors */

/* Constructor function */
Declaration module_decl(SignatureDecl as_sig,TypeDecl as_tfunc,Declarations contents){
  TNODE _node = create_tnode(8383,3);
  assert_SignatureDecl(as_sig);
  _node->children[0] = (void *)as_sig;
  assert_TypeDecl(as_tfunc);
  _node->children[1] = (void *)as_tfunc;
  assert_Declarations(contents);
  _node->children[2] = (void *)contents;
  return (Declaration)_node;
}
/* Accessors */
SignatureDecl module_decl_as_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_as_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (SignatureDecl)((TNODE)_node)->children[0];
}
TypeDecl module_decl_as_tfunc(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_as_tfunc: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (TypeDecl)((TNODE)_node)->children[1];
}
Declarations module_decl_contents(Declaration _node){
  if (Declaration_KEY(_node) != KEYmodule_decl) {
    fatal_error("module_decl_contents: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration signature_decl(SignatureDecl as_sig,Declaration creating,Declarations contents){
  TNODE _node = create_tnode(8484,3);
  assert_SignatureDecl(as_sig);
  _node->children[0] = (void *)as_sig;
  assert_Declaration(creating);
  _node->children[1] = (void *)creating;
  assert_Declarations(contents);
  _node->children[2] = (void *)contents;
  return (Declaration)_node;
}
/* Accessors */
SignatureDecl signature_decl_as_sig(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_decl) {
    fatal_error("signature_decl_as_sig: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (SignatureDecl)((TNODE)_node)->children[0];
}
Declaration signature_decl_creating(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_decl) {
    fatal_error("signature_decl_creating: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[1];
}
Declarations signature_decl_contents(Declaration _node){
  if (Declaration_KEY(_node) != KEYsignature_decl) {
    fatal_error("signature_decl_contents: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration phylum_decl(TypeDecl as_type,Type type_){
  TNODE _node = create_tnode(8585,2);
  assert_TypeDecl(as_type);
  _node->children[0] = (void *)as_type;
  assert_Type(type_);
  _node->children[1] = (void *)type_;
  return (Declaration)_node;
}
/* Accessors */
TypeDecl phylum_decl_as_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_decl) {
    fatal_error("phylum_decl_as_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (TypeDecl)((TNODE)_node)->children[0];
}
Type phylum_decl_type_(Declaration _node){
  if (Declaration_KEY(_node) != KEYphylum_decl) {
    fatal_error("phylum_decl_type_: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration constructor_decl(ValueDecl as_value,PatternDecl as_pattern,Declaration body){
  TNODE _node = create_tnode(8686,3);
  assert_ValueDecl(as_value);
  _node->children[0] = (void *)as_value;
  assert_PatternDecl(as_pattern);
  _node->children[1] = (void *)as_pattern;
  assert_Declaration(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl constructor_decl_as_value(Declaration _node){
  if (Declaration_KEY(_node) != KEYconstructor_decl) {
    fatal_error("constructor_decl_as_value: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
PatternDecl constructor_decl_as_pattern(Declaration _node){
  if (Declaration_KEY(_node) != KEYconstructor_decl) {
    fatal_error("constructor_decl_as_pattern: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (PatternDecl)((TNODE)_node)->children[1];
}
Declaration constructor_decl_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYconstructor_decl) {
    fatal_error("constructor_decl_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration attribute_decl(ValueDecl as_value,Direction direction,Default default_){
  TNODE _node = create_tnode(8787,3);
  assert_ValueDecl(as_value);
  _node->children[0] = (void *)as_value;
  assert_Direction(direction);
  _node->children[1] = (void *)direction;
  assert_Default(default_);
  _node->children[2] = (void *)default_;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl attribute_decl_as_value(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_as_value: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Direction attribute_decl_direction(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_direction: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Direction)((TNODE)_node)->children[1];
}
Default attribute_decl_default(Declaration _node){
  if (Declaration_KEY(_node) != KEYattribute_decl) {
    fatal_error("attribute_decl_default: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Default)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration type_decl(TypeDecl as_type,Type type_){
  TNODE _node = create_tnode(8888,2);
  assert_TypeDecl(as_type);
  _node->children[0] = (void *)as_type;
  assert_Type(type_);
  _node->children[1] = (void *)type_;
  return (Declaration)_node;
}
/* Accessors */
TypeDecl type_decl_as_type(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_decl) {
    fatal_error("type_decl_as_type: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (TypeDecl)((TNODE)_node)->children[0];
}
Type type_decl_type_(Declaration _node){
  if (Declaration_KEY(_node) != KEYtype_decl) {
    fatal_error("type_decl_type_: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration function_decl(ValueDecl as_value,Declaration body){
  TNODE _node = create_tnode(8989,2);
  assert_ValueDecl(as_value);
  _node->children[0] = (void *)as_value;
  assert_Declaration(body);
  _node->children[1] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl function_decl_as_value(Declaration _node){
  if (Declaration_KEY(_node) != KEYfunction_decl) {
    fatal_error("function_decl_as_value: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Declaration function_decl_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYfunction_decl) {
    fatal_error("function_decl_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration procedure_decl(ValueDecl as_value,Declaration body){
  TNODE _node = create_tnode(9090,2);
  assert_ValueDecl(as_value);
  _node->children[0] = (void *)as_value;
  assert_Declaration(body);
  _node->children[1] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl procedure_decl_as_value(Declaration _node){
  if (Declaration_KEY(_node) != KEYprocedure_decl) {
    fatal_error("procedure_decl_as_value: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Declaration procedure_decl_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYprocedure_decl) {
    fatal_error("procedure_decl_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration top_level_match(Match m){
  TNODE _node = create_tnode(9191,1);
  assert_Match(m);
  _node->children[0] = (void *)m;
  return (Declaration)_node;
}
/* Accessors */
Match top_level_match_m(Declaration _node){
  if (Declaration_KEY(_node) != KEYtop_level_match) {
    fatal_error("top_level_match_m: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Match)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration value_decl(ValueDecl as_value,Direction direction,Default default_){
  TNODE _node = create_tnode(9292,3);
  assert_ValueDecl(as_value);
  _node->children[0] = (void *)as_value;
  assert_Direction(direction);
  _node->children[1] = (void *)direction;
  assert_Default(default_);
  _node->children[2] = (void *)default_;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl value_decl_as_value(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_as_value: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Direction value_decl_direction(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_direction: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Direction)((TNODE)_node)->children[1];
}
Default value_decl_default(Declaration _node){
  if (Declaration_KEY(_node) != KEYvalue_decl) {
    fatal_error("value_decl_default: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Default)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration pattern_decl(PatternDecl as_pattern,Pattern choices){
  TNODE _node = create_tnode(9393,2);
  assert_PatternDecl(as_pattern);
  _node->children[0] = (void *)as_pattern;
  assert_Pattern(choices);
  _node->children[1] = (void *)choices;
  return (Declaration)_node;
}
/* Accessors */
PatternDecl pattern_decl_as_pattern(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_decl) {
    fatal_error("pattern_decl_as_pattern: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (PatternDecl)((TNODE)_node)->children[0];
}
Pattern pattern_decl_choices(Declaration _node){
  if (Declaration_KEY(_node) != KEYpattern_decl) {
    fatal_error("pattern_decl_choices: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration inheritance(Type used,Renamings renamings){
  TNODE _node = create_tnode(9494,2);
  assert_Type(used);
  _node->children[0] = (void *)used;
  assert_Renamings(renamings);
  _node->children[1] = (void *)renamings;
  return (Declaration)_node;
}
/* Accessors */
Type inheritance_used(Declaration _node){
  if (Declaration_KEY(_node) != KEYinheritance) {
    fatal_error("inheritance_used: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Renamings inheritance_renamings(Declaration _node){
  if (Declaration_KEY(_node) != KEYinheritance) {
    fatal_error("inheritance_renamings: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Renamings)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration pragma_decl(Symbol name,Expressions parameters){
  TNODE _node = create_tnode(9595,2);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_Expressions(parameters);
  _node->children[1] = (void *)parameters;
  return (Declaration)_node;
}
/* Accessors */
Symbol pragma_decl_name(Declaration _node){
  if (Declaration_KEY(_node) != KEYpragma_decl) {
    fatal_error("pragma_decl_name: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
Expressions pragma_decl_parameters(Declaration _node){
  if (Declaration_KEY(_node) != KEYpragma_decl) {
    fatal_error("pragma_decl_parameters: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming no_renaming(){
  TNODE _node = create_tnode(9696,0);
  return (Renaming)_node;
}
/* Accessors */

/* Constructor function */
Renaming signature_replacement(Signature old,Signature ew){
  TNODE _node = create_tnode(9797,2);
  assert_Signature(old);
  _node->children[0] = (void *)old;
  assert_Signature(ew);
  _node->children[1] = (void *)ew;
  return (Renaming)_node;
}
/* Accessors */
Signature signature_replacement_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYsignature_replacement) {
    fatal_error("signature_replacement_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}
Signature signature_replacement_ew(Renaming _node){
  if (Renaming_KEY(_node) != KEYsignature_replacement) {
    fatal_error("signature_replacement_ew: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming type_replacement(Type old,Type new){
  TNODE _node = create_tnode(9898,2);
  assert_Type(old);
  _node->children[0] = (void *)old;
  assert_Type(new);
  _node->children[1] = (void *)new;
  return (Renaming)_node;
}
/* Accessors */
Type type_replacement_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYtype_replacement) {
    fatal_error("type_replacement_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Type type_replacement_new(Renaming _node){
  if (Renaming_KEY(_node) != KEYtype_replacement) {
    fatal_error("type_replacement_new: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming value_replacement(Expression old,Expression new){
  TNODE _node = create_tnode(9999,2);
  assert_Expression(old);
  _node->children[0] = (void *)old;
  assert_Expression(new);
  _node->children[1] = (void *)new;
  return (Renaming)_node;
}
/* Accessors */
Expression value_replacement_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYvalue_replacement) {
    fatal_error("value_replacement_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression value_replacement_new(Renaming _node){
  if (Renaming_KEY(_node) != KEYvalue_replacement) {
    fatal_error("value_replacement_new: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming pattern_replacement(Pattern old,Pattern new){
  TNODE _node = create_tnode(10100,2);
  assert_Pattern(old);
  _node->children[0] = (void *)old;
  assert_Pattern(new);
  _node->children[1] = (void *)new;
  return (Renaming)_node;
}
/* Accessors */
Pattern pattern_replacement_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYpattern_replacement) {
    fatal_error("pattern_replacement_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Pattern pattern_replacement_new(Renaming _node){
  if (Renaming_KEY(_node) != KEYpattern_replacement) {
    fatal_error("pattern_replacement_new: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming signature_renaming(SignatureDecl decl,Signature old,Renamings elements){
  TNODE _node = create_tnode(10201,3);
  assert_SignatureDecl(decl);
  _node->children[0] = (void *)decl;
  assert_Signature(old);
  _node->children[1] = (void *)old;
  assert_Renamings(elements);
  _node->children[2] = (void *)elements;
  return (Renaming)_node;
}
/* Accessors */
SignatureDecl signature_renaming_decl(Renaming _node){
  if (Renaming_KEY(_node) != KEYsignature_renaming) {
    fatal_error("signature_renaming_decl: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (SignatureDecl)((TNODE)_node)->children[0];
}
Signature signature_renaming_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYsignature_renaming) {
    fatal_error("signature_renaming_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}
Renamings signature_renaming_elements(Renaming _node){
  if (Renaming_KEY(_node) != KEYsignature_renaming) {
    fatal_error("signature_renaming_elements: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Renamings)((TNODE)_node)->children[2];
}

/* Constructor function */
Renaming type_renaming(TypeDecl decl,Type old){
  TNODE _node = create_tnode(10302,2);
  assert_TypeDecl(decl);
  _node->children[0] = (void *)decl;
  assert_Type(old);
  _node->children[1] = (void *)old;
  return (Renaming)_node;
}
/* Accessors */
TypeDecl type_renaming_decl(Renaming _node){
  if (Renaming_KEY(_node) != KEYtype_renaming) {
    fatal_error("type_renaming_decl: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (TypeDecl)((TNODE)_node)->children[0];
}
Type type_renaming_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYtype_renaming) {
    fatal_error("type_renaming_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming value_renaming(ValueDecl decl,Expression old){
  TNODE _node = create_tnode(10403,2);
  assert_ValueDecl(decl);
  _node->children[0] = (void *)decl;
  assert_Expression(old);
  _node->children[1] = (void *)old;
  return (Renaming)_node;
}
/* Accessors */
ValueDecl value_renaming_decl(Renaming _node){
  if (Renaming_KEY(_node) != KEYvalue_renaming) {
    fatal_error("value_renaming_decl: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Expression value_renaming_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYvalue_renaming) {
    fatal_error("value_renaming_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Renaming pattern_renaming(PatternDecl decl,Pattern old){
  TNODE _node = create_tnode(10504,2);
  assert_PatternDecl(decl);
  _node->children[0] = (void *)decl;
  assert_Pattern(old);
  _node->children[1] = (void *)old;
  return (Renaming)_node;
}
/* Accessors */
PatternDecl pattern_renaming_decl(Renaming _node){
  if (Renaming_KEY(_node) != KEYpattern_renaming) {
    fatal_error("pattern_renaming_decl: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (PatternDecl)((TNODE)_node)->children[0];
}
Pattern pattern_renaming_old(Renaming _node){
  if (Renaming_KEY(_node) != KEYpattern_renaming) {
    fatal_error("pattern_renaming_old: called with %s",
                Renaming_constructors[Renaming_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Direction no_direction(Boolean is_input){
  TNODE _node = create_tnode(10605,1);
  assert_Boolean(is_input);
  _node->children[0] = (void *)is_input;
  return (Direction)_node;
}
/* Accessors */
Boolean no_direction_is_input(Direction _node){
  if (Direction_KEY(_node) != KEYno_direction) {
    fatal_error("no_direction_is_input: called with %s",
                Direction_constructors[Direction_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[0];
}

/* Constructor function */
Direction collection_(Boolean is_input){
  TNODE _node = create_tnode(10706,1);
  assert_Boolean(is_input);
  _node->children[0] = (void *)is_input;
  return (Direction)_node;
}
/* Accessors */
Boolean collection__is_input(Direction _node){
  if (Direction_KEY(_node) != KEYcollection_) {
    fatal_error("collection__is_input: called with %s",
                Direction_constructors[Direction_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[0];
}

/* Constructor function */
Direction circular_(Boolean is_input){
  TNODE _node = create_tnode(10807,1);
  assert_Boolean(is_input);
  _node->children[0] = (void *)is_input;
  return (Direction)_node;
}
/* Accessors */
Boolean circular__is_input(Direction _node){
  if (Direction_KEY(_node) != KEYcircular_) {
    fatal_error("circular__is_input: called with %s",
                Direction_constructors[Direction_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[0];
}

/* Constructor function */
Default simple(Expression value){
  TNODE _node = create_tnode(10908,1);
  assert_Expression(value);
  _node->children[0] = (void *)value;
  return (Default)_node;
}
/* Accessors */
Expression simple_value(Default _node){
  if (Default_KEY(_node) != KEYsimple) {
    fatal_error("simple_value: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Default composite(Expression initial,Expression combiner){
  TNODE _node = create_tnode(11009,2);
  assert_Expression(initial);
  _node->children[0] = (void *)initial;
  assert_Expression(combiner);
  _node->children[1] = (void *)combiner;
  return (Default)_node;
}
/* Accessors */
Expression composite_initial(Default _node){
  if (Default_KEY(_node) != KEYcomposite) {
    fatal_error("composite_initial: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression composite_combiner(Default _node){
  if (Default_KEY(_node) != KEYcomposite) {
    fatal_error("composite_combiner: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Default lattice(Expression bottom,Expression join,Expression equal){
  TNODE _node = create_tnode(11110,3);
  assert_Expression(bottom);
  _node->children[0] = (void *)bottom;
  assert_Expression(join);
  _node->children[1] = (void *)join;
  assert_Expression(equal);
  _node->children[2] = (void *)equal;
  return (Default)_node;
}
/* Accessors */
Expression lattice_bottom(Default _node){
  if (Default_KEY(_node) != KEYlattice) {
    fatal_error("lattice_bottom: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression lattice_join(Default _node){
  if (Default_KEY(_node) != KEYlattice) {
    fatal_error("lattice_join: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}
Expression lattice_equal(Default _node){
  if (Default_KEY(_node) != KEYlattice) {
    fatal_error("lattice_equal: called with %s",
                Default_constructors[Default_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[2];
}

/* Constructor function */
Default no_default(){
  TNODE _node = create_tnode(11211,0);
  return (Default)_node;
}
/* Accessors */

/* Constructor function */
SignatureDecl a_signature(Symbol name,TypeFormals type_formals,Boolean constant_,Boolean exported){
  TNODE _node = create_tnode(11312,4);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_TypeFormals(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Boolean(constant_);
  _node->children[2] = (void *)constant_;
  assert_Boolean(exported);
  _node->children[3] = (void *)exported;
  return (SignatureDecl)_node;
}
/* Accessors */
Symbol a_signature_name(SignatureDecl _node){
  if (SignatureDecl_KEY(_node) != KEYa_signature) {
    fatal_error("a_signature_name: called with %s",
                SignatureDecl_constructors[SignatureDecl_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
TypeFormals a_signature_type_formals(SignatureDecl _node){
  if (SignatureDecl_KEY(_node) != KEYa_signature) {
    fatal_error("a_signature_type_formals: called with %s",
                SignatureDecl_constructors[SignatureDecl_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[1];
}
Boolean a_signature_constant_(SignatureDecl _node){
  if (SignatureDecl_KEY(_node) != KEYa_signature) {
    fatal_error("a_signature_constant_: called with %s",
                SignatureDecl_constructors[SignatureDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[2];
}
Boolean a_signature_exported(SignatureDecl _node){
  if (SignatureDecl_KEY(_node) != KEYa_signature) {
    fatal_error("a_signature_exported: called with %s",
                SignatureDecl_constructors[SignatureDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[3];
}

/* Constructor function */
TypeDecl a_type(Symbol name,TypeFormals type_formals,Signatures signatures,Boolean constant_,Boolean exported){
  TNODE _node = create_tnode(11413,5);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_TypeFormals(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Signatures(signatures);
  _node->children[2] = (void *)signatures;
  assert_Boolean(constant_);
  _node->children[3] = (void *)constant_;
  assert_Boolean(exported);
  _node->children[4] = (void *)exported;
  return (TypeDecl)_node;
}
/* Accessors */
Symbol a_type_name(TypeDecl _node){
  if (TypeDecl_KEY(_node) != KEYa_type) {
    fatal_error("a_type_name: called with %s",
                TypeDecl_constructors[TypeDecl_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
TypeFormals a_type_type_formals(TypeDecl _node){
  if (TypeDecl_KEY(_node) != KEYa_type) {
    fatal_error("a_type_type_formals: called with %s",
                TypeDecl_constructors[TypeDecl_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[1];
}
Signatures a_type_signatures(TypeDecl _node){
  if (TypeDecl_KEY(_node) != KEYa_type) {
    fatal_error("a_type_signatures: called with %s",
                TypeDecl_constructors[TypeDecl_KEY(_node)]);
  }
  return (Signatures)((TNODE)_node)->children[2];
}
Boolean a_type_constant_(TypeDecl _node){
  if (TypeDecl_KEY(_node) != KEYa_type) {
    fatal_error("a_type_constant_: called with %s",
                TypeDecl_constructors[TypeDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[3];
}
Boolean a_type_exported(TypeDecl _node){
  if (TypeDecl_KEY(_node) != KEYa_type) {
    fatal_error("a_type_exported: called with %s",
                TypeDecl_constructors[TypeDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[4];
}

/* Constructor function */
ValueDecl a_value(Symbol name,TypeFormals type_formals,Type type_,Boolean constant_,Boolean exported){
  TNODE _node = create_tnode(11514,5);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_TypeFormals(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Type(type_);
  _node->children[2] = (void *)type_;
  assert_Boolean(constant_);
  _node->children[3] = (void *)constant_;
  assert_Boolean(exported);
  _node->children[4] = (void *)exported;
  return (ValueDecl)_node;
}
/* Accessors */
Symbol a_value_name(ValueDecl _node){
  if (ValueDecl_KEY(_node) != KEYa_value) {
    fatal_error("a_value_name: called with %s",
                ValueDecl_constructors[ValueDecl_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
TypeFormals a_value_type_formals(ValueDecl _node){
  if (ValueDecl_KEY(_node) != KEYa_value) {
    fatal_error("a_value_type_formals: called with %s",
                ValueDecl_constructors[ValueDecl_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[1];
}
Type a_value_type_(ValueDecl _node){
  if (ValueDecl_KEY(_node) != KEYa_value) {
    fatal_error("a_value_type_: called with %s",
                ValueDecl_constructors[ValueDecl_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[2];
}
Boolean a_value_constant_(ValueDecl _node){
  if (ValueDecl_KEY(_node) != KEYa_value) {
    fatal_error("a_value_constant_: called with %s",
                ValueDecl_constructors[ValueDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[3];
}
Boolean a_value_exported(ValueDecl _node){
  if (ValueDecl_KEY(_node) != KEYa_value) {
    fatal_error("a_value_exported: called with %s",
                ValueDecl_constructors[ValueDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[4];
}

/* Constructor function */
PatternDecl a_pattern(Symbol name,TypeFormals type_formals,Type type_,Boolean constant_,Boolean exported){
  TNODE _node = create_tnode(11615,5);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  assert_TypeFormals(type_formals);
  _node->children[1] = (void *)type_formals;
  assert_Type(type_);
  _node->children[2] = (void *)type_;
  assert_Boolean(constant_);
  _node->children[3] = (void *)constant_;
  assert_Boolean(exported);
  _node->children[4] = (void *)exported;
  return (PatternDecl)_node;
}
/* Accessors */
Symbol a_pattern_name(PatternDecl _node){
  if (PatternDecl_KEY(_node) != KEYa_pattern) {
    fatal_error("a_pattern_name: called with %s",
                PatternDecl_constructors[PatternDecl_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}
TypeFormals a_pattern_type_formals(PatternDecl _node){
  if (PatternDecl_KEY(_node) != KEYa_pattern) {
    fatal_error("a_pattern_type_formals: called with %s",
                PatternDecl_constructors[PatternDecl_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[1];
}
Type a_pattern_type_(PatternDecl _node){
  if (PatternDecl_KEY(_node) != KEYa_pattern) {
    fatal_error("a_pattern_type_: called with %s",
                PatternDecl_constructors[PatternDecl_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[2];
}
Boolean a_pattern_constant_(PatternDecl _node){
  if (PatternDecl_KEY(_node) != KEYa_pattern) {
    fatal_error("a_pattern_constant_: called with %s",
                PatternDecl_constructors[PatternDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[3];
}
Boolean a_pattern_exported(PatternDecl _node){
  if (PatternDecl_KEY(_node) != KEYa_pattern) {
    fatal_error("a_pattern_exported: called with %s",
                PatternDecl_constructors[PatternDecl_KEY(_node)]);
  }
  return (Boolean)((TNODE)_node)->children[4];
}

/* Constructor function */
Type type_name(Symbol name){
  TNODE _node = create_tnode(11716,1);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  return (Type)_node;
}
/* Accessors */
Symbol type_name_name(Type _node){
  if (Type_KEY(_node) != KEYtype_name) {
    fatal_error("type_name_name: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}

/* Constructor function */
Type no_type(){
  TNODE _node = create_tnode(11817,0);
  return (Type)_node;
}
/* Accessors */

/* Constructor function */
Type type_inst(Type base,TypeActuals type_actuals,Actuals actuals){
  TNODE _node = create_tnode(11918,3);
  assert_Type(base);
  _node->children[0] = (void *)base;
  assert_TypeActuals(type_actuals);
  _node->children[1] = (void *)type_actuals;
  assert_Actuals(actuals);
  _node->children[2] = (void *)actuals;
  return (Type)_node;
}
/* Accessors */
Type type_inst_base(Type _node){
  if (Type_KEY(_node) != KEYtype_inst) {
    fatal_error("type_inst_base: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
TypeActuals type_inst_type_actuals(Type _node){
  if (Type_KEY(_node) != KEYtype_inst) {
    fatal_error("type_inst_type_actuals: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}
Actuals type_inst_actuals(Type _node){
  if (Type_KEY(_node) != KEYtype_inst) {
    fatal_error("type_inst_actuals: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[2];
}

/* Constructor function */
Type qual_type(Type inst,Type type_){
  TNODE _node = create_tnode(12019,2);
  assert_Type(inst);
  _node->children[0] = (void *)inst;
  assert_Type(type_);
  _node->children[1] = (void *)type_;
  return (Type)_node;
}
/* Accessors */
Type qual_type_inst(Type _node){
  if (Type_KEY(_node) != KEYqual_type) {
    fatal_error("qual_type_inst: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Type qual_type_type_(Type _node){
  if (Type_KEY(_node) != KEYqual_type) {
    fatal_error("qual_type_type_: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression value_name(Symbol name){
  TNODE _node = create_tnode(12120,1);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  return (Expression)_node;
}
/* Accessors */
Symbol value_name_name(Expression _node){
  if (Expression_KEY(_node) != KEYvalue_name) {
    fatal_error("value_name_name: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression value_inst(Expression base,TypeActuals actuals){
  TNODE _node = create_tnode(12221,2);
  assert_Expression(base);
  _node->children[0] = (void *)base;
  assert_TypeActuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Expression)_node;
}
/* Accessors */
Expression value_inst_base(Expression _node){
  if (Expression_KEY(_node) != KEYvalue_inst) {
    fatal_error("value_inst_base: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
TypeActuals value_inst_actuals(Expression _node){
  if (Expression_KEY(_node) != KEYvalue_inst) {
    fatal_error("value_inst_actuals: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression qual_value(Type inst,Expression value){
  TNODE _node = create_tnode(12322,2);
  assert_Type(inst);
  _node->children[0] = (void *)inst;
  assert_Expression(value);
  _node->children[1] = (void *)value;
  return (Expression)_node;
}
/* Accessors */
Type qual_value_inst(Expression _node){
  if (Expression_KEY(_node) != KEYqual_value) {
    fatal_error("qual_value_inst: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Expression qual_value_value(Expression _node){
  if (Expression_KEY(_node) != KEYqual_value) {
    fatal_error("qual_value_value: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Signature sig_name(Symbol name){
  TNODE _node = create_tnode(12423,1);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  return (Signature)_node;
}
/* Accessors */
Symbol sig_name_name(Signature _node){
  if (Signature_KEY(_node) != KEYsig_name) {
    fatal_error("sig_name_name: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}

/* Constructor function */
Signature no_sig(){
  TNODE _node = create_tnode(12524,0);
  return (Signature)_node;
}
/* Accessors */

/* Constructor function */
Signature sig_inst(Signature sig,TypeActuals actuals){
  TNODE _node = create_tnode(12625,2);
  assert_Signature(sig);
  _node->children[0] = (void *)sig;
  assert_TypeActuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Signature)_node;
}
/* Accessors */
Signature sig_inst_sig(Signature _node){
  if (Signature_KEY(_node) != KEYsig_inst) {
    fatal_error("sig_inst_sig: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}
TypeActuals sig_inst_actuals(Signature _node){
  if (Signature_KEY(_node) != KEYsig_inst) {
    fatal_error("sig_inst_actuals: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Signature qual_sig(Type inst,Signature sig){
  TNODE _node = create_tnode(12726,2);
  assert_Type(inst);
  _node->children[0] = (void *)inst;
  assert_Signature(sig);
  _node->children[1] = (void *)sig;
  return (Signature)_node;
}
/* Accessors */
Type qual_sig_inst(Signature _node){
  if (Signature_KEY(_node) != KEYqual_sig) {
    fatal_error("qual_sig_inst: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Signature qual_sig_sig(Signature _node){
  if (Signature_KEY(_node) != KEYqual_sig) {
    fatal_error("qual_sig_sig: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern pattern_name(Symbol name){
  TNODE _node = create_tnode(12827,1);
  assert_Symbol(name);
  _node->children[0] = (void *)name;
  return (Pattern)_node;
}
/* Accessors */
Symbol pattern_name_name(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_name) {
    fatal_error("pattern_name_name: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Symbol)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern no_pattern(){
  TNODE _node = create_tnode(12928,0);
  return (Pattern)_node;
}
/* Accessors */

/* Constructor function */
Pattern pattern_inst(Pattern base,TypeActuals actuals){
  TNODE _node = create_tnode(13029,2);
  assert_Pattern(base);
  _node->children[0] = (void *)base;
  assert_TypeActuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Pattern)_node;
}
/* Accessors */
Pattern pattern_inst_base(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_inst) {
    fatal_error("pattern_inst_base: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
TypeActuals pattern_inst_actuals(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_inst) {
    fatal_error("pattern_inst_actuals: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (TypeActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern qual_pattern(Type inst,Pattern pattern){
  TNODE _node = create_tnode(13130,2);
  assert_Type(inst);
  _node->children[0] = (void *)inst;
  assert_Pattern(pattern);
  _node->children[1] = (void *)pattern;
  return (Pattern)_node;
}
/* Accessors */
Type qual_pattern_inst(Pattern _node){
  if (Pattern_KEY(_node) != KEYqual_pattern) {
    fatal_error("qual_pattern_inst: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Pattern qual_pattern_pattern(Pattern _node){
  if (Pattern_KEY(_node) != KEYqual_pattern) {
    fatal_error("qual_pattern_pattern: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Signature var_sig(Signature sig){
  TNODE _node = create_tnode(13231,1);
  assert_Signature(sig);
  _node->children[0] = (void *)sig;
  return (Signature)_node;
}
/* Accessors */
Signature var_sig_sig(Signature _node){
  if (Signature_KEY(_node) != KEYvar_sig) {
    fatal_error("var_sig_sig: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}

/* Constructor function */
Signature constant_sig(Signature sig){
  TNODE _node = create_tnode(13332,1);
  assert_Signature(sig);
  _node->children[0] = (void *)sig;
  return (Signature)_node;
}
/* Accessors */
Signature constant_sig_sig(Signature _node){
  if (Signature_KEY(_node) != KEYconstant_sig) {
    fatal_error("constant_sig_sig: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}

/* Constructor function */
Signature module_sig(TypeFormals type_formals,Formals formals,Declaration return_type){
  TNODE _node = create_tnode(13433,3);
  assert_TypeFormals(type_formals);
  _node->children[0] = (void *)type_formals;
  assert_Formals(formals);
  _node->children[1] = (void *)formals;
  assert_Declaration(return_type);
  _node->children[2] = (void *)return_type;
  return (Signature)_node;
}
/* Accessors */
TypeFormals module_sig_type_formals(Signature _node){
  if (Signature_KEY(_node) != KEYmodule_sig) {
    fatal_error("module_sig_type_formals: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[0];
}
Formals module_sig_formals(Signature _node){
  if (Signature_KEY(_node) != KEYmodule_sig) {
    fatal_error("module_sig_formals: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Formals)((TNODE)_node)->children[1];
}
Declaration module_sig_return_type(Signature _node){
  if (Signature_KEY(_node) != KEYmodule_sig) {
    fatal_error("module_sig_return_type: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Signature fixed_sig(Types types){
  TNODE _node = create_tnode(13534,1);
  assert_Types(types);
  _node->children[0] = (void *)types;
  return (Signature)_node;
}
/* Accessors */
Types fixed_sig_types(Signature _node){
  if (Signature_KEY(_node) != KEYfixed_sig) {
    fatal_error("fixed_sig_types: called with %s",
                Signature_constructors[Signature_KEY(_node)]);
  }
  return (Types)((TNODE)_node)->children[0];
}

/* Constructor function */
Type remote_type(Type nodetype){
  TNODE _node = create_tnode(13635,1);
  assert_Type(nodetype);
  _node->children[0] = (void *)nodetype;
  return (Type)_node;
}
/* Accessors */
Type remote_type_nodetype(Type _node){
  if (Type_KEY(_node) != KEYremote_type) {
    fatal_error("remote_type_nodetype: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Type ordered_set_type(Type u,Expression equal,Expression order){
  TNODE _node = create_tnode(13736,3);
  assert_Type(u);
  _node->children[0] = (void *)u;
  assert_Expression(equal);
  _node->children[1] = (void *)equal;
  assert_Expression(order);
  _node->children[2] = (void *)order;
  return (Type)_node;
}
/* Accessors */
Type ordered_set_type_u(Type _node){
  if (Type_KEY(_node) != KEYordered_set_type) {
    fatal_error("ordered_set_type_u: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Expression ordered_set_type_equal(Type _node){
  if (Type_KEY(_node) != KEYordered_set_type) {
    fatal_error("ordered_set_type_equal: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}
Expression ordered_set_type_order(Type _node){
  if (Type_KEY(_node) != KEYordered_set_type) {
    fatal_error("ordered_set_type_order: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[2];
}

/* Constructor function */
Type set_type(Type u,Expression equal){
  TNODE _node = create_tnode(13837,2);
  assert_Type(u);
  _node->children[0] = (void *)u;
  assert_Expression(equal);
  _node->children[1] = (void *)equal;
  return (Type)_node;
}
/* Accessors */
Type set_type_u(Type _node){
  if (Type_KEY(_node) != KEYset_type) {
    fatal_error("set_type_u: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}
Expression set_type_equal(Type _node){
  if (Type_KEY(_node) != KEYset_type) {
    fatal_error("set_type_equal: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Type list_type(Type u){
  TNODE _node = create_tnode(13938,1);
  assert_Type(u);
  _node->children[0] = (void *)u;
  return (Type)_node;
}
/* Accessors */
Type list_type_u(Type _node){
  if (Type_KEY(_node) != KEYlist_type) {
    fatal_error("list_type_u: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Type function_type(Formals formals,Declaration return_value){
  TNODE _node = create_tnode(14039,2);
  assert_Formals(formals);
  _node->children[0] = (void *)formals;
  assert_Declaration(return_value);
  _node->children[1] = (void *)return_value;
  return (Type)_node;
}
/* Accessors */
Formals function_type_formals(Type _node){
  if (Type_KEY(_node) != KEYfunction_type) {
    fatal_error("function_type_formals: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Formals)((TNODE)_node)->children[0];
}
Declaration function_type_return_value(Type _node){
  if (Type_KEY(_node) != KEYfunction_type) {
    fatal_error("function_type_return_value: called with %s",
                Type_constructors[Type_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern simple_pattern(Pattern con,PatternActuals actuals){
  TNODE _node = create_tnode(14140,2);
  assert_Pattern(con);
  _node->children[0] = (void *)con;
  assert_PatternActuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Pattern)_node;
}
/* Accessors */
Pattern simple_pattern_con(Pattern _node){
  if (Pattern_KEY(_node) != KEYsimple_pattern) {
    fatal_error("simple_pattern_con: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
PatternActuals simple_pattern_actuals(Pattern _node){
  if (Pattern_KEY(_node) != KEYsimple_pattern) {
    fatal_error("simple_pattern_actuals: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (PatternActuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern pattern_actual(Pattern arg,Expression formal){
  TNODE _node = create_tnode(14241,2);
  assert_Pattern(arg);
  _node->children[0] = (void *)arg;
  assert_Expression(formal);
  _node->children[1] = (void *)formal;
  return (Pattern)_node;
}
/* Accessors */
Pattern pattern_actual_arg(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_actual) {
    fatal_error("pattern_actual_arg: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Expression pattern_actual_formal(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_actual) {
    fatal_error("pattern_actual_formal: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern sequence_pattern(Patterns actuals,Type type_){
  TNODE _node = create_tnode(14342,2);
  assert_Patterns(actuals);
  _node->children[0] = (void *)actuals;
  assert_Type(type_);
  _node->children[1] = (void *)type_;
  return (Pattern)_node;
}
/* Accessors */
Patterns sequence_pattern_actuals(Pattern _node){
  if (Pattern_KEY(_node) != KEYsequence_pattern) {
    fatal_error("sequence_pattern_actuals: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[0];
}
Type sequence_pattern_type_(Pattern _node){
  if (Pattern_KEY(_node) != KEYsequence_pattern) {
    fatal_error("sequence_pattern_type_: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern rest_pattern(Pattern constraint){
  TNODE _node = create_tnode(14443,1);
  assert_Pattern(constraint);
  _node->children[0] = (void *)constraint;
  return (Pattern)_node;
}
/* Accessors */
Pattern rest_pattern_constraint(Pattern _node){
  if (Pattern_KEY(_node) != KEYrest_pattern) {
    fatal_error("rest_pattern_constraint: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern choice_pattern(Patterns choices){
  TNODE _node = create_tnode(14544,1);
  assert_Patterns(choices);
  _node->children[0] = (void *)choices;
  return (Pattern)_node;
}
/* Accessors */
Patterns choice_pattern_choices(Pattern _node){
  if (Pattern_KEY(_node) != KEYchoice_pattern) {
    fatal_error("choice_pattern_choices: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Patterns)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern and_pattern(Pattern p1,Pattern p2){
  TNODE _node = create_tnode(14645,2);
  assert_Pattern(p1);
  _node->children[0] = (void *)p1;
  assert_Pattern(p2);
  _node->children[1] = (void *)p2;
  return (Pattern)_node;
}
/* Accessors */
Pattern and_pattern_p1(Pattern _node){
  if (Pattern_KEY(_node) != KEYand_pattern) {
    fatal_error("and_pattern_p1: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}
Pattern and_pattern_p2(Pattern _node){
  if (Pattern_KEY(_node) != KEYand_pattern) {
    fatal_error("and_pattern_p2: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}

/* Constructor function */
Pattern pattern_var(ValueDecl as_value){
  TNODE _node = create_tnode(14746,1);
  assert_ValueDecl(as_value);
  _node->children[0] = (void *)as_value;
  return (Pattern)_node;
}
/* Accessors */
ValueDecl pattern_var_as_value(Pattern _node){
  if (Pattern_KEY(_node) != KEYpattern_var) {
    fatal_error("pattern_var_as_value: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}

/* Constructor function */
Pattern condition(Expression e){
  TNODE _node = create_tnode(14847,1);
  assert_Expression(e);
  _node->children[0] = (void *)e;
  return (Pattern)_node;
}
/* Accessors */
Expression condition_e(Pattern _node){
  if (Pattern_KEY(_node) != KEYcondition) {
    fatal_error("condition_e: called with %s",
                Pattern_constructors[Pattern_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration stmts(Declarations body){
  TNODE _node = create_tnode(14948,1);
  assert_Declarations(body);
  _node->children[0] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
Declarations stmts_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYstmts) {
    fatal_error("stmts_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declarations)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration effect(Expression e){
  TNODE _node = create_tnode(15049,1);
  assert_Expression(e);
  _node->children[0] = (void *)e;
  return (Declaration)_node;
}
/* Accessors */
Expression effect_e(Declaration _node){
  if (Declaration_KEY(_node) != KEYeffect) {
    fatal_error("effect_e: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Declaration assign(Expression lhs,Expression rhs){
  TNODE _node = create_tnode(15150,2);
  assert_Expression(lhs);
  _node->children[0] = (void *)lhs;
  assert_Expression(rhs);
  _node->children[1] = (void *)rhs;
  return (Declaration)_node;
}
/* Accessors */
Expression assign_lhs(Declaration _node){
  if (Declaration_KEY(_node) != KEYassign) {
    fatal_error("assign_lhs: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression assign_rhs(Declaration _node){
  if (Declaration_KEY(_node) != KEYassign) {
    fatal_error("assign_rhs: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration if_stmt(Expression cond,Declaration if_true,Declaration if_false){
  TNODE _node = create_tnode(15251,3);
  assert_Expression(cond);
  _node->children[0] = (void *)cond;
  assert_Declaration(if_true);
  _node->children[1] = (void *)if_true;
  assert_Declaration(if_false);
  _node->children[2] = (void *)if_false;
  return (Declaration)_node;
}
/* Accessors */
Expression if_stmt_cond(Declaration _node){
  if (Declaration_KEY(_node) != KEYif_stmt) {
    fatal_error("if_stmt_cond: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Declaration if_stmt_if_true(Declaration _node){
  if (Declaration_KEY(_node) != KEYif_stmt) {
    fatal_error("if_stmt_if_true: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[1];
}
Declaration if_stmt_if_false(Declaration _node){
  if (Declaration_KEY(_node) != KEYif_stmt) {
    fatal_error("if_stmt_if_false: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration for_in_stmt(ValueDecl formal,Expression seq,Declaration body){
  TNODE _node = create_tnode(15352,3);
  assert_ValueDecl(formal);
  _node->children[0] = (void *)formal;
  assert_Expression(seq);
  _node->children[1] = (void *)seq;
  assert_Declaration(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl for_in_stmt_formal(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_in_stmt) {
    fatal_error("for_in_stmt_formal: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Expression for_in_stmt_seq(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_in_stmt) {
    fatal_error("for_in_stmt_seq: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}
Declaration for_in_stmt_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_in_stmt) {
    fatal_error("for_in_stmt_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration for_on_stmt(ValueDecl formal,Expression seq,Declaration body){
  TNODE _node = create_tnode(15453,3);
  assert_ValueDecl(formal);
  _node->children[0] = (void *)formal;
  assert_Expression(seq);
  _node->children[1] = (void *)seq;
  assert_Declaration(body);
  _node->children[2] = (void *)body;
  return (Declaration)_node;
}
/* Accessors */
ValueDecl for_on_stmt_formal(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_on_stmt) {
    fatal_error("for_on_stmt_formal: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[0];
}
Expression for_on_stmt_seq(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_on_stmt) {
    fatal_error("for_on_stmt_seq: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}
Declaration for_on_stmt_body(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_on_stmt) {
    fatal_error("for_on_stmt_body: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Declaration for_stmt(Expression expr,Matches matchers){
  TNODE _node = create_tnode(15554,2);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Matches(matchers);
  _node->children[1] = (void *)matchers;
  return (Declaration)_node;
}
/* Accessors */
Expression for_stmt_expr(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_stmt) {
    fatal_error("for_stmt_expr: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Matches for_stmt_matchers(Declaration _node){
  if (Declaration_KEY(_node) != KEYfor_stmt) {
    fatal_error("for_stmt_matchers: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[1];
}

/* Constructor function */
Declaration case_stmt(Expression expr,Matches matchers,Declaration default_){
  TNODE _node = create_tnode(15655,3);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Matches(matchers);
  _node->children[1] = (void *)matchers;
  assert_Declaration(default_);
  _node->children[2] = (void *)default_;
  return (Declaration)_node;
}
/* Accessors */
Expression case_stmt_expr(Declaration _node){
  if (Declaration_KEY(_node) != KEYcase_stmt) {
    fatal_error("case_stmt_expr: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Matches case_stmt_matchers(Declaration _node){
  if (Declaration_KEY(_node) != KEYcase_stmt) {
    fatal_error("case_stmt_matchers: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Matches)((TNODE)_node)->children[1];
}
Declaration case_stmt_default(Declaration _node){
  if (Declaration_KEY(_node) != KEYcase_stmt) {
    fatal_error("case_stmt_default: called with %s",
                Declaration_constructors[Declaration_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Match matcher(TypeFormals polymorphism,Pattern pat,Declaration stmt){
  TNODE _node = create_tnode(15756,3);
  assert_TypeFormals(polymorphism);
  _node->children[0] = (void *)polymorphism;
  assert_Pattern(pat);
  _node->children[1] = (void *)pat;
  assert_Declaration(stmt);
  _node->children[2] = (void *)stmt;
  return (Match)_node;
}
/* Accessors */
TypeFormals matcher_polymorphism(Match _node){
  if (Match_KEY(_node) != KEYmatcher) {
    fatal_error("matcher_polymorphism: called with %s",
                Match_constructors[Match_KEY(_node)]);
  }
  return (TypeFormals)((TNODE)_node)->children[0];
}
Pattern matcher_pat(Match _node){
  if (Match_KEY(_node) != KEYmatcher) {
    fatal_error("matcher_pat: called with %s",
                Match_constructors[Match_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[1];
}
Declaration matcher_stmt(Match _node){
  if (Match_KEY(_node) != KEYmatcher) {
    fatal_error("matcher_stmt: called with %s",
                Match_constructors[Match_KEY(_node)]);
  }
  return (Declaration)((TNODE)_node)->children[2];
}

/* Constructor function */
Expression integer_const(String token){
  TNODE _node = create_tnode(15857,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String integer_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYinteger_const) {
    fatal_error("integer_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression string_const(String token){
  TNODE _node = create_tnode(15958,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String string_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYstring_const) {
    fatal_error("string_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression char_const(String token){
  TNODE _node = create_tnode(16059,1);
  assert_String(token);
  _node->children[0] = (void *)token;
  return (Expression)_node;
}
/* Accessors */
String char_const_token(Expression _node){
  if (Expression_KEY(_node) != KEYchar_const) {
    fatal_error("char_const_token: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (String)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression undefined(){
  TNODE _node = create_tnode(16160,0);
  return (Expression)_node;
}
/* Accessors */

/* Constructor function */
Expression no_expr(){
  TNODE _node = create_tnode(16261,0);
  return (Expression)_node;
}
/* Accessors */

/* Constructor function */
Expression funcall(Expression f,Actuals actuals){
  TNODE _node = create_tnode(16362,2);
  assert_Expression(f);
  _node->children[0] = (void *)f;
  assert_Actuals(actuals);
  _node->children[1] = (void *)actuals;
  return (Expression)_node;
}
/* Accessors */
Expression funcall_f(Expression _node){
  if (Expression_KEY(_node) != KEYfuncall) {
    fatal_error("funcall_f: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Actuals funcall_actuals(Expression _node){
  if (Expression_KEY(_node) != KEYfuncall) {
    fatal_error("funcall_actuals: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Actuals)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression reduce(Expression f,Expressions elems){
  TNODE _node = create_tnode(16463,2);
  assert_Expression(f);
  _node->children[0] = (void *)f;
  assert_Expressions(elems);
  _node->children[1] = (void *)elems;
  return (Expression)_node;
}
/* Accessors */
Expression reduce_f(Expression _node){
  if (Expression_KEY(_node) != KEYreduce) {
    fatal_error("reduce_f: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expressions reduce_elems(Expression _node){
  if (Expression_KEY(_node) != KEYreduce) {
    fatal_error("reduce_elems: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression sequence(Expressions elems,Type type_){
  TNODE _node = create_tnode(16564,2);
  assert_Expressions(elems);
  _node->children[0] = (void *)elems;
  assert_Type(type_);
  _node->children[1] = (void *)type_;
  return (Expression)_node;
}
/* Accessors */
Expressions sequence_elems(Expression _node){
  if (Expression_KEY(_node) != KEYsequence) {
    fatal_error("sequence_elems: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expressions)((TNODE)_node)->children[0];
}
Type sequence_type_(Expression _node){
  if (Expression_KEY(_node) != KEYsequence) {
    fatal_error("sequence_type_: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression constructor_key(Expression name){
  TNODE _node = create_tnode(16665,1);
  assert_Expression(name);
  _node->children[0] = (void *)name;
  return (Expression)_node;
}
/* Accessors */
Expression constructor_key_name(Expression _node){
  if (Expression_KEY(_node) != KEYconstructor_key) {
    fatal_error("constructor_key_name: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression signature_value(Signature s){
  TNODE _node = create_tnode(16766,1);
  assert_Signature(s);
  _node->children[0] = (void *)s;
  return (Expression)_node;
}
/* Accessors */
Signature signature_value_s(Expression _node){
  if (Expression_KEY(_node) != KEYsignature_value) {
    fatal_error("signature_value_s: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Signature)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression type_value(Type t){
  TNODE _node = create_tnode(16867,1);
  assert_Type(t);
  _node->children[0] = (void *)t;
  return (Expression)_node;
}
/* Accessors */
Type type_value_t(Expression _node){
  if (Expression_KEY(_node) != KEYtype_value) {
    fatal_error("type_value_t: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Type)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression pattern_value(Pattern p){
  TNODE _node = create_tnode(16968,1);
  assert_Pattern(p);
  _node->children[0] = (void *)p;
  return (Expression)_node;
}
/* Accessors */
Pattern pattern_value_p(Expression _node){
  if (Expression_KEY(_node) != KEYpattern_value) {
    fatal_error("pattern_value_p: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Pattern)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression repeat(Expression expr){
  TNODE _node = create_tnode(17069,1);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  return (Expression)_node;
}
/* Accessors */
Expression repeat_expr(Expression _node){
  if (Expression_KEY(_node) != KEYrepeat) {
    fatal_error("repeat_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}

/* Constructor function */
Expression guarded(Expression expr,Expression cond){
  TNODE _node = create_tnode(17170,2);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_Expression(cond);
  _node->children[1] = (void *)cond;
  return (Expression)_node;
}
/* Accessors */
Expression guarded_expr(Expression _node){
  if (Expression_KEY(_node) != KEYguarded) {
    fatal_error("guarded_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
Expression guarded_cond(Expression _node){
  if (Expression_KEY(_node) != KEYguarded) {
    fatal_error("guarded_cond: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[1];
}

/* Constructor function */
Expression controlled(Expression expr,ValueDecl decl,Expression set){
  TNODE _node = create_tnode(17271,3);
  assert_Expression(expr);
  _node->children[0] = (void *)expr;
  assert_ValueDecl(decl);
  _node->children[1] = (void *)decl;
  assert_Expression(set);
  _node->children[2] = (void *)set;
  return (Expression)_node;
}
/* Accessors */
Expression controlled_expr(Expression _node){
  if (Expression_KEY(_node) != KEYcontrolled) {
    fatal_error("controlled_expr: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[0];
}
ValueDecl controlled_decl(Expression _node){
  if (Expression_KEY(_node) != KEYcontrolled) {
    fatal_error("controlled_decl: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (ValueDecl)((TNODE)_node)->children[1];
}
Expression controlled_set(Expression _node){
  if (Expression_KEY(_node) != KEYcontrolled) {
    fatal_error("controlled_set: called with %s",
                Expression_constructors[Expression_KEY(_node)]);
  }
  return (Expression)((TNODE)_node)->children[2];
}

